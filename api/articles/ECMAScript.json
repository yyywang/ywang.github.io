{"title":"ECMAScript","slug":"ECMAScript","date":"2019-01-10T07:00:41.000Z","updated":"2019-01-10T10:11:50.016Z","comments":true,"path":"api/articles/ECMAScript.json","photos":[],"link":"","excerpt":"JavaScript 的核心 ECMAScript 描述了该语言的语法和基本对象。","covers":["/2019/01/10/ECMAScript/SmallPascal.JPG","/2019/01/10/ECMAScript/Int.GIF","/2019/01/10/ECMAScript/ToBoolean.JPG","/2019/01/10/ECMAScript/Not.JPG","/2019/01/10/ECMAScript/And.JPG","/2019/01/10/ECMAScript/Or.JPG","/2019/01/10/ECMAScript/Multiplication.JPGg","/2019/01/10/ECMAScript/Division.JPG","/2019/01/10/ECMAScript/Modular.JPG","/2019/01/10/ECMAScript/Addition.JPG","/2019/01/10/ECMAScript/Subtraction.JPG","/2019/01/10/ECMAScript/EqualTranslate.JPG","/2019/01/10/ECMAScript/js_inheritance_implementing.GIF"],"content":"<blockquote>\n<p><strong>JavaScript 的核心 ECMAScript 描述了该语言的语法和基本对象。</strong></p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h2 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1. 基础\"></a>1. 基础</h2><h3 id=\"1-1-语法\"><a href=\"#1-1-语法\" class=\"headerlink\" title=\"1.1 语法\"></a>1.1 语法</h3><h4 id=\"1-1-1-变量是弱类型的，定义变量时只用-var-运算符，可以将它初始化为任何值，因此，可以随时改变变量所存数据的类型（尽量避免这样做）。\"><a href=\"#1-1-1-变量是弱类型的，定义变量时只用-var-运算符，可以将它初始化为任何值，因此，可以随时改变变量所存数据的类型（尽量避免这样做）。\" class=\"headerlink\" title=\"1.1.1 变量是弱类型的，定义变量时只用 var 运算符，可以将它初始化为任何值，因此，可以随时改变变量所存数据的类型（尽量避免这样做）。\"></a>1.1.1 变量是弱类型的，定义变量时只用 <code>var</code> 运算符，可以将它初始化为任何值，因此，可以随时改变变量所存数据的类型（尽量避免这样做）。</h4><h3 id=\"1-2-变量\"><a href=\"#1-2-变量\" class=\"headerlink\" title=\"1.2 变量\"></a>1.2 变量</h3><h4 id=\"1-2-1-命名变量规则\"><a href=\"#1-2-1-命名变量规则\" class=\"headerlink\" title=\"1.2.1 命名变量规则\"></a>1.2.1 命名变量规则</h4><p>① 第一个字符必须是字母、下划线或美元符号；<br>② 余下字符可以时下划线、美元符号或任何字母或数字字符。</p>\n<h4 id=\"1-2-2-著名变量命名法则\"><a href=\"#1-2-2-著名变量命名法则\" class=\"headerlink\" title=\"1.2.2 著名变量命名法则\"></a>1.2.2 著名变量命名法则</h4><p>Camel 标记法、Pascal 标记法、匈牙利类型标记法。<br><img src=\"/2019/01/10/ECMAScript/SmallPascal.JPG\" alt=\"smallPascal\"></p>\n<h4 id=\"1-2-3-变量声明不是必须的\"><a href=\"#1-2-3-变量声明不是必须的\" class=\"headerlink\" title=\"1.2.3 变量声明不是必须的\"></a>1.2.3 变量声明不是必须的</h4><p>ECMAScript 的解释程序遇到未声明过的标识符时，用该变量名创建一个全局变量，并将其初始化未指定的值。</p>\n<h3 id=\"1-3-关键字-25-amp-保留字-31\"><a href=\"#1-3-关键字-25-amp-保留字-31\" class=\"headerlink\" title=\"1.3 关键字 (25) &amp; 保留字 (31)\"></a>1.3 关键字 (25) &amp; 保留字 (31)</h3><h4 id=\"1-3-1-关键字不能用作变量名或函数名\"><a href=\"#1-3-1-关键字不能用作变量名或函数名\" class=\"headerlink\" title=\"1.3.1 关键字不能用作变量名或函数名\"></a>1.3.1 关键字不能用作变量名或函数名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">break, case, catch, continue, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-2-保留字在某种意思上是为将来的关键字而保留的单词，因此不可用作变量名和函数名\"><a href=\"#1-3-2-保留字在某种意思上是为将来的关键字而保留的单词，因此不可用作变量名和函数名\" class=\"headerlink\" title=\"1.3.2 保留字在某种意思上是为将来的关键字而保留的单词，因此不可用作变量名和函数名\"></a>1.3.2 保留字在某种意思上是为将来的关键字而保留的单词，因此不可用作变量名和函数名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abstract, boolean, byte, char, class, const, debugger, double, enum, export, extends, final, float, goto, implements, import, int, interface, long, native, package, private, protected, public, short, static, super, synchronized, throws, transient, volatile</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-值\"><a href=\"#1-4-值\" class=\"headerlink\" title=\"1.4 值\"></a>1.4 值</h3><p>在 ECMAScript 中，变量可以存在两种类型的值，即原始值和引用值。<br>原始值（5种）：存储在栈（stack）中的简单数据段，值直接存储在变量访问的位置。<br>引用值：存储在堆（heap）中的对象，存储在变量处的值是一个指针，指向存储对象的内存处。</p>\n<h3 id=\"1-5-原始类型（5种）\"><a href=\"#1-5-原始类型（5种）\" class=\"headerlink\" title=\"1.5 原始类型（5种）\"></a>1.5 原始类型（5种）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefine, Null, Boolean, Number, String</span><br></pre></td></tr></table></figure>\n<p><code>typeof</code> 运算符判断一个值是否在某种类型的范围内</p>\n<h4 id=\"1-5-1-Undefined-类型\"><a href=\"#1-5-1-Undefined-类型\" class=\"headerlink\" title=\"1.5.1 Undefined 类型\"></a>1.5.1 <code>Undefined</code> 类型</h4><p>只有一个值，即 <code>undefined</code>，当声明的变量未初始化时，该变量的默认值是 <code>undefined</code>；当函数无明确返回值时，返回值也是 <code>undefined</code>。</p>\n<h4 id=\"1-5-2-Null-类型\"><a href=\"#1-5-2-Null-类型\" class=\"headerlink\" title=\"1.5.2 Null 类型\"></a>1.5.2 <code>Null</code> 类型</h4><p>只有一个值 <code>null</code>。<code>undefined</code> 实际上是从 <code>null</code> 派生过来的。ECMAScript 把它们定义为值相等，尽管值相等，但它们的含义不同。<br><code>undefined</code> 是声明了变量但未对其初始化时赋给该变量的值。<br><code>null</code> 用于标识尚未存在的对象。</p>\n<h4 id=\"1-5-3-Boolean-类型\"><a href=\"#1-5-3-Boolean-类型\" class=\"headerlink\" title=\"1.5.3 Boolean 类型\"></a>1.5.3 <code>Boolean</code> 类型</h4><p>只有两个值，<code>true</code> 和 <code>false</code>。</p>\n<h4 id=\"1-5-4-Number-类型\"><a href=\"#1-5-4-Number-类型\" class=\"headerlink\" title=\"1.5.4 Number 类型\"></a>1.5.4 <code>Number</code> 类型</h4><p>既可以表示 32 位的整数还可以表示 64 位的浮点数。直接输入的（而不是从另一个变量访问的）任何数字都被看做 <code>Number</code> 类型的字面量。  </p>\n<blockquote>\n<p><strong>注：字面量，在计算机科学中，用于表达源码中一个固定值的表示法。</strong></p>\n</blockquote>\n<p>整数也可以表示为八进制或十六进制的字面量。八进制字面量的首数字必须是 0；十六进制的首数字必须为 0，后面接字母 x。<strong>尽管所有整数都可以表示为八进制或十六进制的字面量，但所有数学运算返回的都是十进制的结果。</strong><br>要定义浮点值，必须包括小数点和小数点后的一位数字。<br>浮点字面量的有趣之处在于，用它进行计算前，真正存储的是字符串。<br>也可用科学计数法表示小数：<code>num e num；num -e num</code>；<br>特殊的 <code>Number</code> 值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number.MAX_VALUE，Number.MIN_VALUE，Number.POSITIVE_INFINITY，Number.NEGATIVE_INFINITY，NaN（表示非数，产生在类型转换失败时，不能用于计算，与自身不相等）</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-5-5-String-类型\"><a href=\"#1-5-5-String-类型\" class=\"headerlink\" title=\"1.5.5 String 类型\"></a>1.5.5 <code>String</code> 类型</h4><p>是唯一没有固定大小的原始类型。由于 ECMAScript 没有字符类型，所以 <code>&#39;&#39;</code> 或 <code>&quot;&quot;</code> 都可使用。</p>\n<h3 id=\"1-6-引用类型\"><a href=\"#1-6-引用类型\" class=\"headerlink\" title=\"1.6 引用类型\"></a>1.6 引用类型</h3><p>引用类型通常叫做类（class——对象定义），也就是说，遇到引用类型，所处理的就是对象。</p>\n<h4 id=\"1-6-1-Object-对象\"><a href=\"#1-6-1-Object-对象\" class=\"headerlink\" title=\"1.6.1 Object 对象\"></a>1.6.1 <code>Object</code> 对象</h4><p>ECMAScript 中的所有对象都是由这个对象继承而来。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">constructor, prototype, hasOwnProperty(), isPrototypeOf(), propertyIsEnumerable, toString(), valueOf()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-6-2-Boolean-对象\"><a href=\"#1-6-2-Boolean-对象\" class=\"headerlink\" title=\"1.6.2 Boolean 对象\"></a>1.6.2 <code>Boolean</code> 对象</h4><p><code>Boolean</code> 对象是 <code>Boolean</code> 原始类型的引用类型。<br>在 <code>Boolean</code> 表达式中，所有对象都会被自动转换为 <code>true</code>。  </p>\n<pre><code>var oFalseObject = new Boolean(false);\n\noFalseObject == true;  \noFalseObject.valueOf() == false;\n\nvar bResult = oFalseObject &amp;&amp; true; // 输出 true\nvar bResult = oFalseObject.valueOf() &amp;&amp; true; // 输出 false\n</code></pre><h4 id=\"1-6-3-Number-对象\"><a href=\"#1-6-3-Number-对象\" class=\"headerlink\" title=\"1.6.3 Number 对象\"></a>1.6.3 <code>Number</code> 对象</h4><p><code>Number</code> 对象是 <code>Number</code> 原始类型的引用类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">toFixed(), toExponential(), toPrecision()</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-6-4-String-对象\"><a href=\"#1-6-4-String-对象\" class=\"headerlink\" title=\"1.6.4 String 对象\"></a>1.6.4 <code>String</code> 对象</h4><p><code>String</code> 对象是 <code>String</code> 原始类型的对象表示方法。<br><code>String</code> 对象的所有属性和方法都可应用于 <code>String</code> 原始值上，因为它们是伪对象。  </p>\n<blockquote>\n<p><strong>注：所谓伪对象, 首先并不是对象, 换句话说就是值类型, 其因为某种原因（通常是环境增强）可以使用某些相对应对象的方法和属性，以达到 OO 方式的编程目的. 实际上称 <code>Boolean,Number,String</code> 这些内置对象为包装类对象，而称能够编码时调用对应包装类方法和属性的 <code>boolean,number,string</code> 这些基本值类型称为伪对象。</strong></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">length, charAt(), charCodeAt(), concat(), indexOf(), lastIndexOf(), localeCompare(), slice(), substring(), toLowerCase(), toLocaleLowerCase(), toUpperCase(), toLocaleUpperCase(), instanceOf</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"2-运算符\"><a href=\"#2-运算符\" class=\"headerlink\" title=\"2. 运算符\"></a>2. 运算符</h2><h3 id=\"2-1-一元运算符\"><a href=\"#2-1-一元运算符\" class=\"headerlink\" title=\"2.1 一元运算符\"></a>2.1 一元运算符</h3><p>只有一个参数，即要操作的对象或值。</p>\n<h4 id=\"2-1-1-delet\"><a href=\"#2-1-1-delet\" class=\"headerlink\" title=\"2.1.1 delet\"></a>2.1.1 <code>delet</code></h4><p><code>delet</code> 运算符删除对以前定义的对象属性或方法的<strong>引用</strong>，不能删除开发者未定义的属性和方法（包括原始的 ECMAScript 方法）。</p>\n<h4 id=\"2-1-2-void\"><a href=\"#2-1-2-void\" class=\"headerlink\" title=\"2.1.2 void\"></a>2.1.2 void</h4><p><code>void</code> 运算符对任何值返回 <code>undefined</code>。该运算符通常用于避免输出不应该输出的值。没有返回值的函数真正返回的都是 <code>undefined</code>。</p>\n<h4 id=\"2-1-3-自增-自减运算符\"><a href=\"#2-1-3-自增-自减运算符\" class=\"headerlink\" title=\"2.1.3 自增 / 自减运算符\"></a>2.1.3 自增 / 自减运算符</h4><h4 id=\"2-1-4-一元加法和一元减法\"><a href=\"#2-1-4-一元加法和一元减法\" class=\"headerlink\" title=\"2.1.4 一元加法和一元减法\"></a>2.1.4 一元加法和一元减法</h4><p>一元加法本质上对数字无任何影响，但会把字符串转换成数字。<br>一元减法就是对数值求负，也会把字符串转换成近似的数字。</p>\n<h3 id=\"2-2-位运算符\"><a href=\"#2-2-位运算符\" class=\"headerlink\" title=\"2.2 位运算符\"></a>2.2 位运算符</h3><p>位运算是在数字底层（即表示数字的 32 个数位）进行操作的。<br>两种整数类型：有符号整数 &amp; 无符号整数。<br>有符号整数使用 31 位表示整数的数值，用第 32 位表示整数的符号，0 表示正数，1表示负数。<br><img src=\"/2019/01/10/ECMAScript/Int.GIF\" alt=\"Int\"><br>所有整数字面量都默认存储为有符号整数，只有 ECMAScript 的位运算符才能创建无符号整数。</p>\n<h4 id=\"2-2-1-NOT（-）\"><a href=\"#2-2-1-NOT（-）\" class=\"headerlink\" title=\"2.2.1 NOT（~）\"></a>2.2.1 NOT（~）</h4><p>对数 字求负，然后减 1。</p>\n<h4 id=\"2-2-2-AND（-amp-）\"><a href=\"#2-2-2-AND（-amp-）\" class=\"headerlink\" title=\"2.2.2 AND（&amp;）\"></a>2.2.2 AND（&amp;）</h4><h4 id=\"2-2-3-OR（-）\"><a href=\"#2-2-3-OR（-）\" class=\"headerlink\" title=\"2.2.3 OR（|）\"></a>2.2.3 OR（|）</h4><h4 id=\"2-2-4-XOR（-）\"><a href=\"#2-2-4-XOR（-）\" class=\"headerlink\" title=\"2.2.4 XOR（^）\"></a>2.2.4 XOR（^）</h4><h4 id=\"2-2-5-左移运算（-lt-lt-）\"><a href=\"#2-2-5-左移运算（-lt-lt-）\" class=\"headerlink\" title=\"2.2.5 左移运算（&lt;&lt;）\"></a>2.2.5 左移运算（&lt;&lt;）</h4><h4 id=\"2-2-6-有符号右移运算（-gt-gt-）\"><a href=\"#2-2-6-有符号右移运算（-gt-gt-）\" class=\"headerlink\" title=\"2.2.6 有符号右移运算（&gt;&gt;）\"></a>2.2.6 有符号右移运算（&gt;&gt;）</h4><h4 id=\"2-2-7-无符号右移运算（-gt-gt-gt-）\"><a href=\"#2-2-7-无符号右移运算（-gt-gt-gt-）\" class=\"headerlink\" title=\"2.2.7 无符号右移运算（&gt;&gt;&gt;）\"></a>2.2.7 无符号右移运算（&gt;&gt;&gt;）</h4><h3 id=\"2-3-逻辑运算符\"><a href=\"#2-3-逻辑运算符\" class=\"headerlink\" title=\"2.3 逻辑运算符\"></a>2.3 逻辑运算符</h3><p><code>Boolean</code> 运算符非常重要，它使得程序语言得以正常运行。<br><code>Boolean</code> 运算符有三种：NOT、AND 和 OR。</p>\n<h4 id=\"2-3-1-ToBoolean-操作\"><a href=\"#2-3-1-ToBoolean-操作\" class=\"headerlink\" title=\"2.3.1 ToBoolean 操作\"></a>2.3.1 ToBoolean 操作</h4><p>Boolean(para)，(!!para)<br><img src=\"/2019/01/10/ECMAScript/ToBoolean.JPG\" alt=\"ToBoolean\"></p>\n<h4 id=\"2-3-2-逻辑-NOT-运算符（-）\"><a href=\"#2-3-2-逻辑-NOT-运算符（-）\" class=\"headerlink\" title=\"2.3.2 逻辑 NOT 运算符（!）\"></a>2.3.2 逻辑 NOT 运算符（!）</h4><p>逻辑 NOT 运算符返回的一定是 <code>Boolean</code> 值。<br><img src=\"/2019/01/10/ECMAScript/Not.JPG\" alt=\"Not\"></p>\n<h4 id=\"2-3-3-逻辑-AND-运算符（-amp-amp-）\"><a href=\"#2-3-3-逻辑-AND-运算符（-amp-amp-）\" class=\"headerlink\" title=\"2.3.3 逻辑 AND 运算符（&amp;&amp;）\"></a>2.3.3 逻辑 AND 运算符（&amp;&amp;）</h4><p>如果某个运算数不是原始的 <code>Boolean</code> 型值，逻辑 AND 运算并<strong>不一定</strong>返回 <code>Boolean</code> 值。<br>采用简便运算：如果第一个运算数决定了结果，那么不再计算第二个运算数。<br><img src=\"/2019/01/10/ECMAScript/And.JPG\" alt=\"And\"></p>\n<h4 id=\"2-3-4-逻辑-OR-运算符（-）\"><a href=\"#2-3-4-逻辑-OR-运算符（-）\" class=\"headerlink\" title=\"2.3.4 逻辑 OR 运算符（||）\"></a>2.3.4 逻辑 OR 运算符（||）</h4><p>与逻辑 AND 运算符相似，如果某个运算数不是 <code>Boolean</code> 值，逻辑 OR 运算并<strong>不一定</strong>返回 <code>Boolean</code> 值。同样采用简便运算。<br><img src=\"/2019/01/10/ECMAScript/Or.JPG\" alt=\"Or\">  </p>\n<h3 id=\"2-4-乘性运算符\"><a href=\"#2-4-乘性运算符\" class=\"headerlink\" title=\"2.4 乘性运算符\"></a>2.4 乘性运算符</h3><p>需要注意，乘性运算符还具有一些自动转换功能。</p>\n<h4 id=\"2-4-1-乘法运算符（-）\"><a href=\"#2-4-1-乘法运算符（-）\" class=\"headerlink\" title=\"2.4.1 乘法运算符（*）\"></a>2.4.1 乘法运算符（*）</h4><p>在处理特殊值时，ECMAScript 中的乘法有一些特殊行为：<br><img src=\"/2019/01/10/ECMAScript/Multiplication.JPGg\" alt=\"Multiplication\"></p>\n<h4 id=\"2-4-2-除法运算符（-）\"><a href=\"#2-4-2-除法运算符（-）\" class=\"headerlink\" title=\"2.4.2 除法运算符（/）\"></a>2.4.2 除法运算符（/）</h4><p>与乘法运算符相似，在处理特殊值时，除法运算符也有一些特殊行为：<br><img src=\"/2019/01/10/ECMAScript/Division.JPG\" alt=\"Division\"></p>\n<h4 id=\"2-4-3-取模运算符（-）\"><a href=\"#2-4-3-取模运算符（-）\" class=\"headerlink\" title=\"2.4.3 取模运算符（%）\"></a>2.4.3 取模运算符（%）</h4><p>与其他乘性运算符相似，对于特殊值，取模运算符也有特殊行为：<br><img src=\"/2019/01/10/ECMAScript/Modular.JPG\" alt=\"Modular\"></p>\n<h3 id=\"2-5-加性运算符\"><a href=\"#2-5-加性运算符\" class=\"headerlink\" title=\"2.5 加性运算符\"></a>2.5 加性运算符</h3><p>在多数程序设计语言中，加性运算符（即加号和减号）通常时最简单的数学运算符。在 ECMAScript ，加性运算符有大量的特殊行为。</p>\n<h4 id=\"2-5-1-加法运算符（-）\"><a href=\"#2-5-1-加法运算符（-）\" class=\"headerlink\" title=\"2.5.1 加法运算符（+）\"></a>2.5.1 加法运算符（+）</h4><p>与乘性运算符一样，在处理特殊值时，ECMAScript 中的加法也有一些特殊行为：<br><img src=\"/2019/01/10/ECMAScript/Addition.JPG\" alt=\"Addition\"></p>\n<h4 id=\"2-5-2-减法运算符（-）\"><a href=\"#2-5-2-减法运算符（-）\" class=\"headerlink\" title=\"2.5.2 减法运算符（-）\"></a>2.5.2 减法运算符（-）</h4><p>与加法运算符一样，在处理特殊值时，减法运算符也有一些特殊行为：<br><img src=\"/2019/01/10/ECMAScript/Subtraction.JPG\" alt=\"Subtraction\"></p>\n<h3 id=\"2-6-关系运算符（-lt-gt-lt-gt-）\"><a href=\"#2-6-关系运算符（-lt-gt-lt-gt-）\" class=\"headerlink\" title=\"2.6 关系运算符（&lt;, &gt;, &lt;=, &gt;=）\"></a>2.6 关系运算符（&lt;, &gt;, &lt;=, &gt;=）</h3><p>关系运算符执行的是比较运算。每个关系运算符都返回一个布尔值。<br>对两个字符串应用关系运算符，第一个字符串中每个字符的代码都会与第二个字符串中对应位置的字符的代码进行数值比较。<br>比较两个字符串形式的数字时，都是字符串则比较字符对应的代码，否则转换为数字按数字顺序进行比较。根据规则，任何包含 <code>NaN</code> 的关系运算符都要返回 <code>false</code>。</p>\n<h3 id=\"2-7-等性运算符\"><a href=\"#2-7-等性运算符\" class=\"headerlink\" title=\"2.7 等性运算符\"></a>2.7 等性运算符</h3><p>等号和非等号用于处理原始值，全等号和非全等号用于处理对象。</p>\n<h4 id=\"2-7-1-等号和非等号（-，-）\"><a href=\"#2-7-1-等号和非等号（-，-）\" class=\"headerlink\" title=\"2.7.1 等号和非等号（==，!==）\"></a>2.7.1 等号和非等号（==，!==）</h4><p>当且仅当两个运算数运算数相等时，（==）返回 <code>true</code>，（!=）返回 <code>false</code>。为确定两个运算数是否相等，这两个运算符都会进行类型转换。<br><img src=\"/2019/01/10/ECMAScript/EqualTranslate.JPG\" alt=\"EqualTranslate\"></p>\n<h4 id=\"2-7-2-全等号和非全等号（-，-）\"><a href=\"#2-7-2-全等号和非全等号（-，-）\" class=\"headerlink\" title=\"2.7.2 全等号和非全等号（===，!==）\"></a>2.7.2 全等号和非全等号（===，!==）</h4><p>这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。</p>\n<h3 id=\"2-8-条件运算符\"><a href=\"#2-8-条件运算符\" class=\"headerlink\" title=\"2.8 条件运算符\"></a>2.8 条件运算符</h3><p><code>variable = boolean_expression ? true_value : false_value;</code></p>\n<h3 id=\"2-9-赋值运算符\"><a href=\"#2-9-赋值运算符\" class=\"headerlink\" title=\"2.9 赋值运算符\"></a>2.9 赋值运算符</h3><p>简单的赋值运算符由等号（=）实现，只是把等号右边的值赋予等号左边的变量。<br>复合赋值运算符：乘法/赋值（*=），除法/赋值（/=），取模/赋值（%=），加法/赋值（+=），减法/赋值（-=），左移/赋值（&lt;&lt;=），有符号右移/赋值（&gt;&gt;=），无符号右移/赋值（&gt;&gt;&gt;=）</p>\n<h3 id=\"2-10-逗号运算符\"><a href=\"#2-10-逗号运算符\" class=\"headerlink\" title=\"2.10 逗号运算符\"></a>2.10 逗号运算符</h3><p>用逗号运算符可以在一条与剧中执行多个运算。常用于变量声明中。</p>\n<hr>\n<h2 id=\"3-语句\"><a href=\"#3-语句\" class=\"headerlink\" title=\"3. 语句\"></a>3. 语句</h2><h3 id=\"3-1-if-语句\"><a href=\"#3-1-if-语句\" class=\"headerlink\" title=\"3.1 if 语句\"></a>3.1 <code>if</code> 语句</h3><h3 id=\"3-2-迭代语句（循环语句）\"><a href=\"#3-2-迭代语句（循环语句）\" class=\"headerlink\" title=\"3.2 迭代语句（循环语句）\"></a>3.2 迭代语句（循环语句）</h3><p><code>do-while</code> 语句，<code>while</code> 语句，<code>for</code> 语句，<code>for-in</code> 语句（严格的迭代语句，用于枚举对象的属性）</p>\n<h3 id=\"3-3-标签语句\"><a href=\"#3-3-标签语句\" class=\"headerlink\" title=\"3.3 标签语句\"></a>3.3 标签语句</h3><p>可以用下列语句给语句加标签，以便以后调用：<code>Label : statement</code>。</p>\n<h3 id=\"3-4-break-amp-continue-语句\"><a href=\"#3-4-break-amp-continue-语句\" class=\"headerlink\" title=\"3.4 break &amp; continue 语句\"></a>3.4 <code>break</code> &amp; <code>continue</code> 语句</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">break Label；</span><br><span class=\"line\">continue Label;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-with-语句\"><a href=\"#3-5-with-语句\" class=\"headerlink\" title=\"3.5 with 语句\"></a>3.5 <code>with</code> 语句</h3><p><code>with</code> 语句用于设置代码在特定对象中的作用域。<code>with</code> 语句是运行缓慢的代码块，尤其是在已设置了属性值时，如果可能，最好避免使用。<br><code>with (expression) statement</code></p>\n<h3 id=\"3-6-switch-语句\"><a href=\"#3-6-switch-语句\" class=\"headerlink\" title=\"3.6 switch 语句\"></a>3.6 switch 语句</h3><p>在 ECMAScript 中，<code>switch</code> 语句可以用于字符串，而且能用不是常量的值说明情况。</p>\n<hr>\n<h2 id=\"4-函数\"><a href=\"#4-函数\" class=\"headerlink\" title=\"4. 函数\"></a>4. 函数</h2><p>函数是一组可以随时随地运行的语句。<br>函数在执行过 <code>return</code> 语句后立即停止代码。因此，<code>return</code> 语句后的代码都不会被执行。<br>如果函数无明确返回值，或调用了没有参数的 <code>return</code> 语句，那么它真正的返回值是 <code>undefined</code>。</p>\n<h3 id=\"4-1-arguments-对象\"><a href=\"#4-1-arguments-对象\" class=\"headerlink\" title=\"4.1 arguments 对象\"></a>4.1 <code>arguments</code> 对象</h3><p>在函数代码中，使用特殊对象 <code>arguments</code> 存储方法的参数。所以开发者无需明确指出参数名，就能访问它们。<br><strong>与其他程序设计语言不同，ECMAScript 不会验证传递给函数的个数是否等于函数定义的参数个数。开发者定义的函数都可以接受任意个数的参数（根据 Netscape 的文档，最多可接受 255 个），而不会引发任何错误。任何遗漏的参数都会以 <code>undefined</code> 传递给函数，多余的函数将忽略。</strong><br><code>fuTest(a, b, c){};</code>。用 <code>arguments[0]</code> 也可访问第一个参数的值，等同于 <code>a</code>。因此，函数声明可以不加参数，调用时直接传参数；无需明确命名参数，就可以重写函数。</p>\n<h4 id=\"4-1-1-检测函数参数个数\"><a href=\"#4-1-1-检测函数参数个数\" class=\"headerlink\" title=\"4.1.1 检测函数参数个数\"></a>4.1.1 检测函数参数个数</h4><p>引用属性 <code>arguments.length</code> 即可。</p>\n<h4 id=\"4-1-2-模拟函数重载\"><a href=\"#4-1-2-模拟函数重载\" class=\"headerlink\" title=\"4.1.2 模拟函数重载\"></a>4.1.2 模拟函数重载</h4><p>用 <code>arguments</code> 对象判断传递给函数的参数个数，即可模拟函数重载：</p>\n<pre><code>function doAdd() {\n  if(arguments.length == 1) {\n    alert(arguments[0] + 5);\n  } else if(arguments.length == 2) {\n    alert(arguments[0] + arguments[1]);\n  }\n}\n\ndoAdd(10);    //输出 &quot;15&quot;\ndoAdd(40, 20);    //输出 &quot;60&quot;\n</code></pre><h3 id=\"4-2-Function-对象\"><a href=\"#4-2-Function-对象\" class=\"headerlink\" title=\"4.2 Function 对象\"></a>4.2 Function 对象</h3><p><strong>ECMAScript 的函数实际上是功能完整的对象。</strong><br><code>Function</code> 类可以表示开发者定义的任何函数。<br>用 <code>Function</code> 类直接创建函数的语法如下：<br><code>var function_name = new Function(arg1, arg2, ..., argN, function_body);</code><br>在上面的形式中，每个 <code>arg</code> 都是一个参数，最后一个参数是函数主体（要执行的代码）。这些参数必须是字符串。<br>函数只不过是一种引用类型，它们的行为与用 <code>Function</code> 类明确创建的函数行为是相同的。<br>函数名只是指向函数对象的引用值，行为就像其他对象一样。甚至可以使两个变量指向同一个函数：</p>\n<pre><code>var doAdd = new Function(&quot;iNum&quot;, &quot;alert(iNum + 10)&quot;);\nvar alsodoAdd = doAdd;\n\ndoAdd(10);    //输出 &quot;20&quot;\nalsodoAdd(10);    //输出 &quot;20&quot;\n</code></pre><p>函数名只是指向函数的变量，函数可以作为参数传给另一个函数。<br><strong>尽管可以使用 <code>Function</code> 构造函数创建函数，但最好不要使用它，因为用它定义函数比用传统方式要慢得多。不过，所有函数都应看作 <code>Function</code> 类的实例。</strong></p>\n<h4 id=\"4-2-1-Function-对象的-length-属性\"><a href=\"#4-2-1-Function-对象的-length-属性\" class=\"headerlink\" title=\"4.2.1 Function 对象的 length 属性\"></a>4.2.1 <code>Function</code> 对象的 <code>length</code> 属性</h4><p>如前所述，函数属于引用类型，所以它们也有属性和方法。<code>length</code> 属性声明了函数期望的参数个数。</p>\n<h4 id=\"4-2-2-Function-对象的方法\"><a href=\"#4-2-2-Function-对象的方法\" class=\"headerlink\" title=\"4.2.2 Function 对象的方法\"></a>4.2.2 <code>Function</code> 对象的方法</h4><p><code>Function</code> 对象也有与所有对象共享的方法，如：<code>valueOf(), toString(), hasOwnProperty()</code> 等。<br><code>valueOf()</code> 方法和 <code>toString()</code> 方法返回的都是函数的源代码，在调试时尤其有用。</p>\n<h4 id=\"4-2-3-闭包（closure）\"><a href=\"#4-2-3-闭包（closure）\" class=\"headerlink\" title=\"4.2.3 闭包（closure）\"></a>4.2.3 闭包（closure）</h4><p>闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。<br>就像使用任何高级函数一样，使用闭包要小心，因为它们可能会变得非常复杂。</p>\n<hr>\n<h2 id=\"5-对象\"><a href=\"#5-对象\" class=\"headerlink\" title=\"5. 对象\"></a>5. 对象</h2><p>ECMA-262 把对象 <code>object</code> 定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的数组。<br>封装，聚集，继承，多态。</p>\n<h3 id=\"5-1-对象应用\"><a href=\"#5-1-对象应用\" class=\"headerlink\" title=\"5.1 对象应用\"></a>5.1 对象应用</h3><p>对象的创建和销毁都在 JavaScript 执行过程中发生。</p>\n<h4 id=\"5-1-1-在-ECMAScript-中，不能访问对象的物理表示，只能访问对象的引用。\"><a href=\"#5-1-1-在-ECMAScript-中，不能访问对象的物理表示，只能访问对象的引用。\" class=\"headerlink\" title=\"5.1.1 在 ECMAScript 中，不能访问对象的物理表示，只能访问对象的引用。\"></a>5.1.1 在 ECMAScript 中，不能访问对象的物理表示，只能访问对象的引用。</h4><p>每次创建对象，存储在变量中的都是该对象的引用，而不是对象本身。</p>\n<h4 id=\"5-1-2-对象废除\"><a href=\"#5-1-2-对象废除\" class=\"headerlink\" title=\"5.1.2 对象废除\"></a>5.1.2 对象废除</h4><p>ECMAScript 拥有无用存储单元收集程序（grabage collection routine），意味着不必专门销毁对象来释放内存。当再没由对对象的引用时，称该对象被废除（dereference）了。运行无用存储单元收集程序时，所有废除的对象都被销毁。每当函数执行完它的代码，无用存储单元收集程序也会运行。<br>把对象的所有引用都设置为 <code>null</code>，可以强制性地废除对象。<br>废除对象的所有引用时要当心。如果一个对象由两个或更多引用，则要正确废除该对象，必须将其所有引用都设置为 <code>null</code>。</p>\n<h4 id=\"5-1-3-早绑定和晚绑定\"><a href=\"#5-1-3-早绑定和晚绑定\" class=\"headerlink\" title=\"5.1.3 早绑定和晚绑定\"></a>5.1.3 早绑定和晚绑定</h4><p>所谓绑定（binding），即把对象的接口与对象实例结合再一起的方法。<br>早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。<br>晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。<br>ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。</p>\n<h3 id=\"5-2-对象类型\"><a href=\"#5-2-对象类型\" class=\"headerlink\" title=\"5.2 对象类型\"></a>5.2 对象类型</h3><p>一般来说，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象。</p>\n<h4 id=\"5-2-1-本地对象\"><a href=\"#5-2-1-本地对象\" class=\"headerlink\" title=\"5.2.1 本地对象\"></a>5.2.1 本地对象</h4><p>独立于宿主环境的 ECMAScript 实现提供的对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object, Function, Array, String, Boolean, Number, Date, RegExp, Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URLError</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-2-2-内置对象\"><a href=\"#5-2-2-内置对象\" class=\"headerlink\" title=\"5.2.2 内置对象\"></a>5.2.2 内置对象</h4><p>由 ECMASCript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现。每个内置对象也是本地对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Global，Math</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-2-3-宿主对象\"><a href=\"#5-2-3-宿主对象\" class=\"headerlink\" title=\"5.2.3 宿主对象\"></a>5.2.3 宿主对象</h4><p>所有非本地对象都是宿主对象（host object），即由 ECMASCript 实现的宿主环境提供的对象。<br>所有 BOM 和 DOM 对象都是宿主对象。</p>\n<h3 id=\"5-3-对象作用域\"><a href=\"#5-3-对象作用域\" class=\"headerlink\" title=\"5.3 对象作用域\"></a>5.3 对象作用域</h3><p>作用域指的的变量的适用范围。</p>\n<h4 id=\"5-3-1-ECMAScript-中只存在一种作用域-公用作用域。\"><a href=\"#5-3-1-ECMAScript-中只存在一种作用域-公用作用域。\" class=\"headerlink\" title=\"5.3.1 ECMAScript 中只存在一种作用域 - 公用作用域。\"></a>5.3.1 ECMAScript 中只存在一种作用域 - 公用作用域。</h4><p>ECMAScript 中的所有对象的所有属性和方法都是公用的。<br>由于缺少私有作用域，开发者确定了一个规约，说明哪些属性和方法应该被看做私有的。这种规约约定在属性前后加下划线：<code>obj._color_ = &quot;blue&quot;</code>。下划线并不改变属性是公用属性的事实，它只是告诉其他开发者，应该把该属性看作私有的。有些开发者还喜欢用单下划线说明私有成员，例如：<code>obj._color</code>。</p>\n<h4 id=\"5-3-2-静态作用域\"><a href=\"#5-3-2-静态作用域\" class=\"headerlink\" title=\"5.3.2 静态作用域\"></a>5.3.2 静态作用域</h4><p>静态作用域定义的属性和方法任何时候都能从同一位置访问。类可具有属性和方法，无需实例化该类的对象，即可访问这些属性和方法。<br><strong>ECMAScript没有静态作用域</strong>，不过，它可以给构造函数提供属性和方法。还记得吗，构造函数只是函数，函数是对象，对象可以由属性和方法。</p>\n<h4 id=\"5-3-3-关键字-this\"><a href=\"#5-3-3-关键字-this\" class=\"headerlink\" title=\"5.3.3 关键字 this\"></a>5.3.3 关键字 <code>this</code></h4><p>关键字 <code>this</code> 总是指向调用该方法的对象。<br>为什么使用 <code>this</code> 呢？因为在实例化对象时，总是不能确定开发者会使用什么样的变量名。使用 <code>this</code>，即可在任何多地方重用同一个函数。</p>\n<h3 id=\"5-4-定义类或对象\"><a href=\"#5-4-定义类或对象\" class=\"headerlink\" title=\"5.4 定义类或对象\"></a>5.4 定义类或对象</h3><p>原始方式：直接创建一个对象<br>工厂方式：创建工厂函数，通过 <code>return</code> 返回一个对象，可通过调用工厂函数创建多个对象，但会重复生成对象方法；通过在函数外定义对象的方法，然后通过属性指向该方法，从而避免这个问题，但从语义上讲，该函数不太像是对象的方法<br>构造函数方式：与工厂方式类似，通过 <code>new</code> 创建一个对象，但更像 ECMAScript 中一般对象的创建方式；但依然存在多次创建函数对象的问题<br>原型方式：首先用空构造函数来设置类名，然后所有的属性和方法都被直接赋予 <code>prototype</code> 属性。使用这种方式，还能用 <code>instanceof</code> 运算符检查给定变量指向的对象的类型。但是这个构造函数没有参数，不能通过给构造函数传递参数来初始化属性的值，还没完，真正的问题出现在属性指向的是对象而不是函数时，当某一实例改变属性所指对象的值，所有的对象中属性所指对象的值都会被改变。<br>混合的构造函数 / 原型方式：用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。<br>动态原型方法：基本想法与混合的构造函数 / 原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。直到检查 <code>typeof Car._initialized</code> 是否等于 <code>&quot;undefined&quot;</code> 之前，这个构造函数都未发生变化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Car(sColor,iDoors,iMpg) &#123;</span><br><span class=\"line\">  this.color = sColor;</span><br><span class=\"line\">  this.doors = iDoors;</span><br><span class=\"line\">  this.mpg = iMpg;</span><br><span class=\"line\">  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (typeof Car._initialized == &quot;undefined&quot;) &#123;</span><br><span class=\"line\">    Car.prototype.showColor = function() &#123;</span><br><span class=\"line\">      alert(this.color);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    Car._initialized = true;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>混合工厂方式：这种方式通常是不能应用前一种方式时的变通方法。它的目的是创建假构造函数，只返回另一种对象的新实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Car() &#123;</span><br><span class=\"line\">  var oTempCar = new Object;</span><br><span class=\"line\">  oTempCar.color = &quot;blue&quot;;</span><br><span class=\"line\">  oTempCar.doors = 4;</span><br><span class=\"line\">  oTempCar.mpg = 25;</span><br><span class=\"line\"></span><br><span class=\"line\">  oTempCar.showColor = function() &#123;</span><br><span class=\"line\">    alert(this.color);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  return oTempCar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var car = new Car();</span><br></pre></td></tr></table></figure></p>\n<p>与经典方式不同，这种方式使用 <code>new</code> 运算符，使它看起来像真正的构造函数，由于在 <code>Car()</code> 构造函数内部调用了 <code>new</code> 运算符，所以将忽略第二个 <code>new</code> 运算符（位于构造函数之外），在构造函数内部创建的对象被传递回变量 <code>car</code>。</p>\n<h3 id=\"5-5-修改对象\"><a href=\"#5-5-修改对象\" class=\"headerlink\" title=\"5.5 修改对象\"></a>5.5 修改对象</h3><p>通过使用 ECMAScript，不仅可以创建对象，还可以修改已有对象的行为。<br><code>prototype</code> 属性不仅可以定义构造函数的属性和方法，还可以为本地对象添加属性和方法。</p>\n<h4 id=\"5-5-1-创建新方法\"><a href=\"#5-5-1-创建新方法\" class=\"headerlink\" title=\"5.5.1 创建新方法\"></a>5.5.1 创建新方法</h4><p>用 <code>prototype</code> 属性可以为任何已有的类定义新方法。<br>为已有的方法命名更易懂的名称，只让它们调用原方法就行。<br>添加与已有方法无关的方法。<br>为本地对象添加新方法，必须在 <code>Object</code> 对象的 <code>prototype</code> 属性上定义它。</p>\n<h4 id=\"5-5-2-重定义已有方法\"><a href=\"#5-5-2-重定义已有方法\" class=\"headerlink\" title=\"5.5.2 重定义已有方法\"></a>5.5.2 重定义已有方法</h4><p>就像能给已有的类定义新方法一样，也可重定义已有的方法。如前面的章节所述，函数名只是指向函数的指针，因此可以轻松地指向其他函数。覆盖原始函数，它将被无用存储单元回收程序回收，因为它被完全废弃了。没有能够恢复原始函数地方法，所以在覆盖原始方法前，比较安全地做法是存储它地指针，以便以后地使用。有时甚至可能在新方法中调用原始方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.originalToString = Function.prototype.toString;</span><br><span class=\"line\"></span><br><span class=\"line\">Function.prototype.toString = function() &#123;</span><br><span class=\"line\">  if (this.originalToString().length &gt; 100) &#123;</span><br><span class=\"line\">    return &quot;Function too long to display.&quot;;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    return this.originalToString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-5-3-极晚绑定（Very-Late-Binding）\"><a href=\"#5-5-3-极晚绑定（Very-Late-Binding）\" class=\"headerlink\" title=\"5.5.3 极晚绑定（Very Late Binding）\"></a>5.5.3 极晚绑定（Very Late Binding）</h4><p>从技术上讲，根本不存在极晚绑定，采用该术语描述 ECMAScript 中的一种现象。即能够在对象实例化后再定义它地方法。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o = new Object();</span><br><span class=\"line\"></span><br><span class=\"line\">Object.prototype.sayHi = function () &#123;</span><br><span class=\"line\">  alert(&quot;hi&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">o.sayHi();</span><br></pre></td></tr></table></figure></p>\n<p>在大多数程序设计语言中，必须在实例化对象之前定义对象地方法。</p>\n<hr>\n<h2 id=\"6-继承\"><a href=\"#6-继承\" class=\"headerlink\" title=\"6. 继承\"></a>6. 继承</h2><p>所有开发者定义的类都可作为基类。出于安全原因，本地类和宿主类不能作为基类，这样可以防止公用访问编译过的浏览器级的代码，因为这些代码可以被用于恶意攻击。<br>有时可能想创建一个不能直接使用的基类，它只是用于给子类提供通用的函数。在这种情况下，基类被看做抽象类。<br>所有的属性和方法都是公用的，因此子类可以直接访问这些方法。子类还可添加超类中没有的新属性和方法，也可以覆盖超类的属性和方法。</p>\n<h3 id=\"6-1继承方式\"><a href=\"#6-1继承方式\" class=\"headerlink\" title=\"6.1继承方式\"></a>6.1继承方式</h3><p>和其他功能一样，ECMAScript 实现继承的方式不止一种。这是因为 JavaScript 中的继承机制并不是明确规定的，而是通过模仿实现的。这意味着所有的继承细节并非完全由解释程序处理。</p>\n<h4 id=\"6-1-1-对象冒充（object-masquerading）\"><a href=\"#6-1-1-对象冒充（object-masquerading）\" class=\"headerlink\" title=\"6.1.1 对象冒充（object masquerading）\"></a>6.1.1 对象冒充（object masquerading）</h4><p>构造函数使用 <code>this</code> 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 <code>ClassA</code> 构造函数成为 <code>ClassB</code> 的方法，然后调用它。<code>ClassB</code> 就会收到 <code>ClassA</code> 的构造函数中定义的属性和方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ClassA(sColor) &#123;</span><br><span class=\"line\">    this.color = sColor;</span><br><span class=\"line\">    this.sayColor = function () &#123;</span><br><span class=\"line\">        alert(this.color);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function ClassB(sColor) &#123;</span><br><span class=\"line\">    this.newMethod = ClassA;</span><br><span class=\"line\">    this.newMethod(sColor);</span><br><span class=\"line\">    delete this.newMethod;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>所有新属性和新方法都必须在删除了新方法的代码后定义。否则，可能会覆盖超类的相关属性和方法。<br>有趣的是，对象冒充可以支持多重继承。<br><img src=\"/2019/01/10/ECMAScript/js_inheritance_implementing.GIF\" alt=\"js_inheritance_implementing\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ClassZ() &#123;</span><br><span class=\"line\">    this.newMethod = ClassX;</span><br><span class=\"line\">    this.newMethod();</span><br><span class=\"line\">    delete this.newMethod;</span><br><span class=\"line\"></span><br><span class=\"line\">    this.newMethod = ClassY;</span><br><span class=\"line\">    this.newMethod();</span><br><span class=\"line\">    delete this.newMethod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function ClassZ() &#123;</span><br><span class=\"line\">    this.newMethod = ClassX;</span><br><span class=\"line\">    this.newMethod();</span><br><span class=\"line\">    delete this.newMethod;</span><br><span class=\"line\"></span><br><span class=\"line\">    this.newMethod = ClassY;</span><br><span class=\"line\">    this.newMethod();</span><br><span class=\"line\">    delete this.newMethod;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里存在一个弊端，如果存在两个类 <code>ClassX</code> 和 <code>ClassY</code> 具有同名的属性或方法，<code>ClassY</code> 具有高优先级，因为它从后面的类继承。</p>\n<h4 id=\"6-1-2-call-方法\"><a href=\"#6-1-2-call-方法\" class=\"headerlink\" title=\"6.1.2 call() 方法\"></a>6.1.2 <code>call()</code> 方法</h4><p>它的第一个参数用作调用它的对象，也就是它内部 <code>this</code> 指向的对象。其他参数都直接传递给函数自身。<code>call()</code> 方法是与经典的对象冒充方法最相似的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayColor(sPrefix,sSuffix) &#123;</span><br><span class=\"line\">    alert(sPrefix + this.color + sSuffix);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = new Object();</span><br><span class=\"line\">obj.color = &quot;blue&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">sayColor.call(obj, &quot;The color is &quot;, &quot;a very nice color indeed.&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">function ClassB(sColor, sName) &#123;</span><br><span class=\"line\">    //this.newMethod = ClassA;</span><br><span class=\"line\">    //this.newMethod(color);</span><br><span class=\"line\">    //delete this.newMethod;</span><br><span class=\"line\">    ClassA.call(this, sColor);</span><br><span class=\"line\"></span><br><span class=\"line\">    this.name = sName;</span><br><span class=\"line\">    this.sayName = function () &#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-1-3-apply-方法\"><a href=\"#6-1-3-apply-方法\" class=\"headerlink\" title=\"6.1.3 apply() 方法\"></a>6.1.3 <code>apply()</code> 方法</h4><p>两个参数，用作 this 的对象和要传递给函数的参数的数组。作用与 call() 相同。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayColor(sPrefix,sSuffix) &#123;</span><br><span class=\"line\">    alert(sPrefix + this.color + sSuffix);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = new Object();</span><br><span class=\"line\">obj.color = &quot;blue&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">sayColor.apply(obj, new Array(&quot;The color is &quot;, &quot;a very nice color indeed.&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">function ClassB(sColor, sName) &#123;</span><br><span class=\"line\">    //this.newMethod = ClassA;</span><br><span class=\"line\">    //this.newMethod(color);</span><br><span class=\"line\">    //delete this.newMethod;</span><br><span class=\"line\">    ClassA.apply(this, new Array(sColor));</span><br><span class=\"line\"></span><br><span class=\"line\">    this.name = sName;</span><br><span class=\"line\">    this.sayName = function () &#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以把 <code>ClassB</code> 的整个 <code>arguments</code> 对象作为第二个参数传递给 <code>apply()</code> 方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ClassB(sColor, sName) &#123;</span><br><span class=\"line\">    //this.newMethod = ClassA;</span><br><span class=\"line\">    //this.newMethod(color);</span><br><span class=\"line\">    //delete this.newMethod;</span><br><span class=\"line\">    ClassA.apply(this, arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">    this.name = sName;</span><br><span class=\"line\">    this.sayName = function () &#123;</span><br><span class=\"line\">        alert(this.name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-1-4-原型链（prototype-chaining）\"><a href=\"#6-1-4-原型链（prototype-chaining）\" class=\"headerlink\" title=\"6.1.4 原型链（prototype chaining）\"></a>6.1.4 原型链（prototype chaining）</h4><p>原型链以一种有趣的方式实现了继承机制。<br><code>prototype</code> 对象是个模板，要实例化的对象都以这个模板为基础。<code>prototype</code> 对象的任何属性和方法都被传递给那个类的所有实例。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ClassA() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ClassA.prototype.color = &quot;blue&quot;;</span><br><span class=\"line\">ClassA.prototype.sayColor = function () &#123;</span><br><span class=\"line\">    alert(this.color);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function ClassB() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ClassB.prototype = new ClassA();</span><br></pre></td></tr></table></figure></p>\n<p><code>ClassB</code> 继承 <code>ClassA</code>，把 <code>ClassA</code> 的实例赋予 <code>ClassB</code> 的 <code>prototype</code> 属性。<br>调用 <code>ClassA</code> 的构造函数，没有给它传递参数。这在原型链中是标准做法，要确保构造函数没有任何参数。与对象冒充相似，子类的所有属性和方法都必须出现在 <code>prototype</code> 属性被赋值后，因为在它之前赋值的所有方法都会被删除。为什么？因为 <code>prototype</code> 属性被替换成了新对象，添加了新方法的原属对象将被销毁。<br>在原型链中，<code>instanceof</code> 运算符的运行方式也很独特。对 <code>ClassB</code> 的所有实例，<code>instanceof</code> 为 <code>ClassA</code> 和 <code>ClassB</code> 都返回 <code>true</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var objB = new ClassB();</span><br><span class=\"line\">alert(objB instanceof ClassA);\t//输出 &quot;true&quot;</span><br><span class=\"line\">alert(objB instanceof ClassB);\t//输出 &quot;true&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-1-5-混合方式\"><a href=\"#6-1-5-混合方式\" class=\"headerlink\" title=\"6.1.5 混合方式\"></a>6.1.5 混合方式</h4><p>用构造函数定义属性，用原型定义方法。用对象冒充继承构造函数的属性，用原型继承 <code>prototype</code> 对象的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function ClassA(sColor) &#123;</span><br><span class=\"line\">    this.color = sColor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ClassA.prototype.sayColor = function () &#123;</span><br><span class=\"line\">    alert(this.color);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function ClassB(sColor, sName) &#123;</span><br><span class=\"line\">    ClassA.call(this, sColor); // 用构造函数定义属性</span><br><span class=\"line\">    this.name = sName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ClassB.prototype = new ClassA(); // 用原型定义方法</span><br><span class=\"line\"></span><br><span class=\"line\">ClassB.prototype.sayName = function () &#123;</span><br><span class=\"line\">    alert(this.name);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","count":1,"path":"api/tags/JavaScript.json"}]}