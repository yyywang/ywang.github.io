{"title":"Python3 基础","slug":"Python3-Basic","date":"2019-01-19T07:22:56.000Z","updated":"2019-01-19T09:32:37.954Z","comments":true,"path":"api/articles/Python3-Basic.json","photos":[],"link":"","excerpt":"1. 基础1.1 查看 Python 版本在命令窗口输入：python -V<br>","covers":["/2019/01/19/Python3-Basic/Intercept.png","/2019/01/19/Python3-Basic/EscapeCharacter.JPG","/2019/01/19/Python3-Basic/FormatCharacter.JPG","/2019/01/19/Python3-Basic/ListIntercept.png","/2019/01/19/Python3-Basic/OperatorPrecedence.JPG","/2019/01/19/Python3-Basic/OpenFileMode.JPG"],"content":"<h2 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1. 基础\"></a>1. 基础</h2><h3 id=\"1-1-查看-Python-版本\"><a href=\"#1-1-查看-Python-版本\" class=\"headerlink\" title=\"1.1 查看 Python 版本\"></a>1.1 查看 Python 版本</h3><p>在命令窗口输入：<code>python -V</code><br><a id=\"more\"></a></p>\n<h3 id=\"1-2-编码\"><a href=\"#1-2-编码\" class=\"headerlink\" title=\"1.2 编码\"></a>1.2 编码</h3><p>默认情况下，Python3 源文件以 UTF-8 编码，也可为源文件指定不同的编码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># _*_ coding: gb-2312 _*_</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-3-保留字（33）\"><a href=\"#1-3-保留字（33）\" class=\"headerlink\" title=\"1.3 保留字（33）\"></a>1.3 保留字（33）</h3><p>Python 的标准库提供了一个 <code>keyword</code> 模块，可以输出当前版本的所有关键字：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import keyword</span><br><span class=\"line\">keyword.kwlist</span><br><span class=\"line\"></span><br><span class=\"line\">False, None, True, and, as, assert, break, class, continue, def, del, elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-4-注释\"><a href=\"#1-4-注释\" class=\"headerlink\" title=\"1.4 注释\"></a>1.4 注释</h3><p>单行注释以 <code>#</code> 开头。<br>多行注释可以用多个 <code>#</code> 号，还有 <code>&#39;&#39;&#39;</code> 和 <code>&quot;&quot;&quot;</code>。</p>\n<h3 id=\"1-5-行与缩进\"><a href=\"#1-5-行与缩进\" class=\"headerlink\" title=\"1.5 行与缩进\"></a>1.5 行与缩进</h3><p>使用缩进来表示代码块，不需要使用大括号 <code>{}</code>。<br>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。<br>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>\n<h3 id=\"1-6-多行语句\"><a href=\"#1-6-多行语句\" class=\"headerlink\" title=\"1.6 多行语句\"></a>1.6 多行语句</h3><p>可使用反斜杠 <code>\\</code> 来实现多行语句<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total = item_one + \\</span><br><span class=\"line\">        item_two + \\</span><br><span class=\"line\">        item_three</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>[]</code>, <code>{}</code>, 或 <code>()</code> 中的多行语句，不需要使用反斜杠 <code>\\</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;,</span><br><span class=\"line\">        &apos;item_four&apos;, &apos;item_five&apos;]</span><br></pre></td></tr></table></figure></p>\n<p>Python 可以在同一行中使用多条语句，语句之间使用分号 <code>;</code> 分隔。</p>\n<h3 id=\"1-7-空行\"><a href=\"#1-7-空行\" class=\"headerlink\" title=\"1.7 空行\"></a>1.7 空行</h3><p>函数之间或类的方法之间用<strong>空行</strong>分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。<br>空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。  </p>\n<blockquote>\n<p>注：空行也是程序代码的一部分。</p>\n</blockquote>\n<h3 id=\"1-8-Print-输出\"><a href=\"#1-8-Print-输出\" class=\"headerlink\" title=\"1.8 Print 输出\"></a>1.8 Print 输出</h3><p><strong><code>print</code> 默认输出是换行的</strong>，如果要实现不换行需要在变量末尾加上 <code>end=&quot;&quot;</code>。</p>\n<h3 id=\"1-9-import-与-from-import\"><a href=\"#1-9-import-与-from-import\" class=\"headerlink\" title=\"1.9 import 与 from...import\"></a>1.9 <code>import</code> 与 <code>from...import</code></h3><p>用 <code>import</code> 或者 <code>from...import</code> 来导入相应的模块。<br>将整个模块（somemodule）导入，格式为：<code>import somemodule</code>。<br>从某个模块中导入某个函数，格式为：<code>from somemodule import somefunction</code>。<br>从某个模块中导入多个函数，格式为：<code>from somemodule import firstfunc, secondfunc, thirdfunc</code>。<br>将某个模块中的全部函数导入，格式为：<code>from somemodule import *</code>。</p>\n<h3 id=\"1-20-数据类型转换\"><a href=\"#1-20-数据类型转换\" class=\"headerlink\" title=\"1.20 数据类型转换\"></a>1.20 数据类型转换</h3><p>数据类型的转换，只需要将数据类型作为函数名即可。将返回一个新的对象，表示转换的值。</p>\n<h3 id=\"1-21-变量\"><a href=\"#1-21-变量\" class=\"headerlink\" title=\"1.21 变量\"></a>1.21 变量</h3><p>变量不需声明，但每个变量在使用前必须赋值，<strong>变量赋值以后该变量才会被创建</strong>。</p>\n<h3 id=\"1-22-多个变量赋值\"><a href=\"#1-22-多个变量赋值\" class=\"headerlink\" title=\"1.22 多个变量赋值\"></a>1.22 多个变量赋值</h3><p>允许同时为多个变量赋相同值。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = b = c = 1</span><br></pre></td></tr></table></figure></p>\n<p>允许同时为不同变量赋不同值。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a, b, c = 1, 2, &quot;ywang&quot;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-23-标准数据类型（6）\"><a href=\"#1-23-标准数据类型（6）\" class=\"headerlink\" title=\"1.23 标准数据类型（6）\"></a>1.23 标准数据类型（6）</h3><p>Number, String, Tuple (不可变数据)<br>List, Set, Dictionary（可变数据）</p>\n<hr>\n<h2 id=\"2-Number（数字）\"><a href=\"#2-Number（数字）\" class=\"headerlink\" title=\"2. Number（数字）\"></a>2. Number（数字）</h2><p>用于存储数值，值不允许改变，这就意味着<strong>如果改变数字数据类型的值，将重新分配内存空间</strong>。<br>四种类型：<code>int, float, bool, complex（复数）</code>。<br>浮点型可使用科学记数法表示（2.5e2 = 2.5 * 10^2 = 250）。<br>可以使用十六进制和八进制来代表整数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0xAAA  #十六进制</span><br><span class=\"line\">0o111  #八进制</span><br></pre></td></tr></table></figure></p>\n<p>可用 <code>del</code> 语句删除一些数字对象的引用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">del var  #删除单个对象的引用</span><br><span class=\"line\">del var_a, var_b  # 删除多个对象的引用</span><br></pre></td></tr></table></figure></p>\n<p><code>type(var)</code> 函数可以用来查询变量所指的对象类型。<br>还可用 <code>isinstance(var, int)</code> 来判断。  </p>\n<blockquote>\n<p>区别：<br><code>type()</code> 不会认为子类是一种父类类型。<br><code>isinstance()</code> 会认为子类是一种父类类型。<br>在混合计算时，Python 会把整型转换成为浮点数。<br>复数由实数部分和虚数部分构成，可以用 <code>a + bj</code>, 或者 <code>complex(a, b)</code> 表示，复数的实部 a 和虚部 b 都是浮点型。</p>\n</blockquote>\n<h3 id=\"2-1-数字类型转换\"><a href=\"#2-1-数字类型转换\" class=\"headerlink\" title=\"2.1 数字类型转换\"></a>2.1 数字类型转换</h3><p><code>int(x)</code> 将 x 转换为一个整数。<br><code>float(x)</code> 将 x 转换到一个浮点数。<br><code>complex(x)</code> 将 x 转换到一个复数，实数部分为 x，虚数部分为 0。<br><code>complex(x, y)</code> 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。</p>\n<hr>\n<h2 id=\"3-String（字符串）\"><a href=\"#3-String（字符串）\" class=\"headerlink\" title=\"3. String（字符串）\"></a>3. String（字符串）</h2><p>字符串用单引号 <code>&#39;</code> 或双引号 <code>&quot;</code> 括起来，同时使用反斜杠 <code>\\</code> 转义特殊字符。如果不想让反斜杠发生转义，可以在字符串前添加一个 <code>r</code>，表示原始字符串。Python 不支持单字符类型，单字符也作为一个字符串使用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; print(&apos;Ru\\noob&apos;)</span><br><span class=\"line\">Ru</span><br><span class=\"line\">oob</span><br><span class=\"line\">&gt;&gt;&gt; print(r&apos;Ru\\noob&apos;)</span><br><span class=\"line\">Ru\\noob</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>按字面意义级联字符串</strong>，如 <code>&quot;this&quot; &quot;is&quot; &quot;string&quot;</code> 会被自动转换为 <code>&quot;this is string&quot;</code>。<br>字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。<br>Python 字符串不能被改变，向一个索引位置赋值，比如 sTest[0] = ‘m’ 会导致错误。<br><code>+</code> 是字符串的连接符，<code>*</code> 表示复制当前字符串，紧跟着的数字为复制的次数。</p>\n<h3 id=\"3-1-字符串截取\"><a href=\"#3-1-字符串截取\" class=\"headerlink\" title=\"3.1 字符串截取\"></a>3.1 字符串截取</h3><p>语法格式：变量[头下标:尾下标:步长]，遵循<strong>左闭右开</strong>原则。<br><img src=\"/2019/01/19/Python3-Basic/Intercept.png\" alt=\"Intercept\"></p>\n<h3 id=\"3-2-转义字符\"><a href=\"#3-2-转义字符\" class=\"headerlink\" title=\"3.2 转义字符\"></a>3.2 转义字符</h3><p>需要在字符中使用特殊字符时，Python 用反斜杠 <code>\\</code> 转义字符。<br><img src=\"/2019/01/19/Python3-Basic/EscapeCharacter.JPG\" alt=\"EscapeCharacter.JPG\"></p>\n<h3 id=\"3-3-字符串格式化\"><a href=\"#3-3-字符串格式化\" class=\"headerlink\" title=\"3.3 字符串格式化\"></a>3.3 字符串格式化</h3><p>支持格式化输出。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print (&quot;我叫 %s 今年 %d 岁!&quot; % (&apos;小明&apos;, 10))</span><br><span class=\"line\">&gt;&gt;&gt; 我叫 小明 今年 10 岁!</span><br></pre></td></tr></table></figure></p>\n<p>字符串格式化符号：<br><img src=\"/2019/01/19/Python3-Basic/FormatCharacter.JPG\" alt=\"FormatCharacter\"><br>格式化操作符辅助指令：<br><img src=\"/2019/01/19/Python3-Basic/Auxiliary.JPG\" alt=\"Auxiliary\"></p>\n<h3 id=\"3-4-三引号\"><a href=\"#3-4-三引号\" class=\"headerlink\" title=\"3.4 三引号\"></a>3.4 三引号</h3><p>反斜杠 <code>\\</code> 可以作为续行符，表示下一行是上一行的延续。也可以使用 <code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或者 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code> 跨越多行。<br>三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。自始至终保持一小块字符串的格式是所谓的 WYSIWYG（所见即所得）格式。</p>\n<h3 id=\"3-5-Unicode-字符串\"><a href=\"#3-5-Unicode-字符串\" class=\"headerlink\" title=\"3.5 Unicode 字符串\"></a>3.5 Unicode 字符串</h3><p>在 Python2 中，普通字符串是以 8 位 ASCII 码进行存储的，而 Unicode 字符串则存储为 16 位 Unicode 字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 <code>u</code>。<br>在 Python3 中，所有的字符串都是 Unicode 字符串。</p>\n<hr>\n<h2 id=\"4-List（列表）\"><a href=\"#4-List（列表）\" class=\"headerlink\" title=\"4. List（列表）\"></a>4. List（列表）</h2><p>序列是 Python 中最基本的数据结构。序列中的每个元素都分配一个数字表示它的位置，或索引，第一个索引是 0，第二个索引是 1，依此类推。<br>Python 有 6 个序列的内置类型，序列都可以进行的操作包括索引，切片，加，乘，检查成员。<br>Python 已经内置确定序列的长度以及确定最大和最小的元素的方法。<br>列表是最常用的 Python 数据类型，可嵌套列表。列表写在方括号 <code>[]</code> 之间，用逗号分隔开元素列表。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。<br>列表截取可以接收第三个参数，参数作用是截取的步长。<br><img src=\"/2019/01/19/Python3-Basic/ListIntercept.png\" alt=\"ListIntercept\"></p>\n<h3 id=\"4-1-访问列表中的值\"><a href=\"#4-1-访问列表中的值\" class=\"headerlink\" title=\"4.1 访问列表中的值\"></a>4.1 访问列表中的值</h3><p>使用下表索引来访问列表中的值，也可使用方括号的形式截取字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000];</span><br><span class=\"line\">list2 = [1, 2, 3, 4, 5, 6, 7 ];</span><br><span class=\"line\"> </span><br><span class=\"line\">print (&quot;list1[0]: &quot;, list1[0])</span><br><span class=\"line\">print (&quot;list2[1:5]: &quot;, list2[1:5])</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-2-更新列表\"><a href=\"#4-2-更新列表\" class=\"headerlink\" title=\"4.2 更新列表\"></a>4.2 更新列表</h3><p>可以对列表的数据项进行修改或更新，也可使用 <code>append()</code> 方法来添加列表项。</p>\n<h3 id=\"4-3-删除列表元素\"><a href=\"#4-3-删除列表元素\" class=\"headerlink\" title=\"4.3 删除列表元素\"></a>4.3 删除列表元素</h3><p>可使用 <code>del</code> 语句来删除列表的元素。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list = [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000]</span><br><span class=\"line\"> </span><br><span class=\"line\">print (&quot;原始列表 : &quot;, list)</span><br><span class=\"line\">del list[2]</span><br><span class=\"line\">print (&quot;删除第三个元素 : &quot;, list)</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">原始列表 :  [&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000]</span><br><span class=\"line\">删除第三个元素 :  [&apos;Google&apos;, &apos;Runoob&apos;, 2000]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"4-4-列表函数-amp-方法\"><a href=\"#4-4-列表函数-amp-方法\" class=\"headerlink\" title=\"4.4 列表函数 &amp; 方法\"></a>4.4 列表函数 &amp; 方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len(list), max(list), min(list), list(seq)</span><br><span class=\"line\">list.append(obj), list.count(obj), list.extend(seq), list.index(obj), list.insert(index, obj), list.pop([index=-1]), list.remove(obj), list.reverse(), list.sort(cmp=None, key=None, reverse=False), list.clear(), list.copy()</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"5-Tuple（元组）\"><a href=\"#5-Tuple（元组）\" class=\"headerlink\" title=\"5. Tuple（元组）\"></a>5. Tuple（元组）</h2><p>元组与列表类似，不同之处在于<strong>元组的元素不能修改</strong>。<br>元组使用小括号，列表使用方括号。<br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;tup1 = (&apos;Google&apos;, &apos;Runoob&apos;, 1997, 2000);</span><br><span class=\"line\">&gt;&gt;&gt; tup2 = (1, 2, 3, 4, 5 );</span><br><span class=\"line\">&gt;&gt;&gt; tup3 = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;;   #  不需要括号也可以</span><br><span class=\"line\">&gt;&gt;&gt; type(tup3)</span><br><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>创建空元组：<code>tup1 = ()</code><br>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符（类型转换）使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;tup1 = (50)</span><br><span class=\"line\">&gt;&gt;&gt; type(tup1)     # 不加逗号，类型为整型</span><br><span class=\"line\">&lt;class &apos;int&apos;&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">&gt;&gt;&gt; tup1 = (50,)</span><br><span class=\"line\">&gt;&gt;&gt; type(tup1)     # 加上逗号，类型为元组</span><br><span class=\"line\">&lt;class &apos;tuple&apos;&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5-1-访问元组\"><a href=\"#5-1-访问元组\" class=\"headerlink\" title=\"5.1 访问元组\"></a>5.1 访问元组</h3><p>使用下标索引访问。</p>\n<h3 id=\"5-2-修改元组\"><a href=\"#5-2-修改元组\" class=\"headerlink\" title=\"5.2 修改元组\"></a>5.2 修改元组</h3><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合。</p>\n<h3 id=\"5-3-删除元组\"><a href=\"#5-3-删除元组\" class=\"headerlink\" title=\"5.3 删除元组\"></a>5.3 删除元组</h3><p>元组中的元素值是不允许删除的，但我们可以使用 <code>del</code> 语句来删除整个元组。</p>\n<h3 id=\"5-4-元组运算符\"><a href=\"#5-4-元组运算符\" class=\"headerlink\" title=\"5.4 元组运算符\"></a>5.4 元组运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len(), +, *, in, for in</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-5-索引，截取\"><a href=\"#5-5-索引，截取\" class=\"headerlink\" title=\"5.5 索引，截取\"></a>5.5 索引，截取</h3><p>同 String 类型进行索引与截取操作。</p>\n<h3 id=\"5-6-内置函数\"><a href=\"#5-6-内置函数\" class=\"headerlink\" title=\"5.6 内置函数\"></a>5.6 内置函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len(), max(), min(), tuple()</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"6-Dictionary（字典）\"><a href=\"#6-Dictionary（字典）\" class=\"headerlink\" title=\"6. Dictionary（字典）\"></a>6. Dictionary（字典）</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>字典的每个键值对用冒号 <code>:</code> 分割，每个对之间用逗号 <code>,</code> 分割，整个字典包括在花括号 <code>{}</code> 中。<br>格式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure></p>\n<p>键是唯一的，但值则不必。<br>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict1 = &#123; &apos;abc&apos;: 456 &#125;;</span><br><span class=\"line\">dict2 = &#123; &apos;abc&apos;: 123, 98.6: 37 &#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"6-1-访问字典中的值\"><a href=\"#6-1-访问字典中的值\" class=\"headerlink\" title=\"6.1 访问字典中的值\"></a>6.1 访问字典中的值</h3><p>把相应的键放入到方括号中。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict = &#123;&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">print (&quot;dict[&apos;Name&apos;]: &quot;, dict[&apos;Name&apos;])</span><br><span class=\"line\">print (&quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;])</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">dict[&apos;Name&apos;]:  Runoob</span><br><span class=\"line\">dict[&apos;Age&apos;]:  7</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注：<br>不允许一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住。<br>键必须不可变，所以可以用数字，字符串或元组充当。</p>\n</blockquote>\n<h3 id=\"6-2-修改字典\"><a href=\"#6-2-修改字典\" class=\"headerlink\" title=\"6.2 修改字典\"></a>6.2 修改字典</h3><p>向字典添加新内容的方法是增加新的键值对，修改或删除已有键值对如下实例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict = &#123;&apos;Name&apos;: &apos;Runoob&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">dict[&apos;Age&apos;] = 8;          # 更新 Age</span><br><span class=\"line\">dict[&apos;School&apos;] = &quot;ywang&quot;  # 添加信息</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"6-3-删除字典元素\"><a href=\"#6-3-删除字典元素\" class=\"headerlink\" title=\"6.3 删除字典元素\"></a>6.3 删除字典元素</h3><p>能删除单一的元素也能清空字典，清空只需一项操作。<br>删除一个字典用 <code>del</code> 命令，清空用 <code>clear()</code> 函数。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dict = &#123;&apos;Name&apos;: &apos;Ywang&apos;, &apos;Age&apos;: 7, &apos;Class&apos;: &apos;First&apos;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">del dict[&apos;Name&apos;] # 删除键 &apos;Name&apos;</span><br><span class=\"line\">dict.clear()     # 清空字典</span><br><span class=\"line\">del dict         # 删除字典</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"6-4-内置函数-amp-方法\"><a href=\"#6-4-内置函数-amp-方法\" class=\"headerlink\" title=\"6.4 内置函数 &amp; 方法\"></a>6.4 内置函数 &amp; 方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len(dict), str(dict), type(variable)</span><br><span class=\"line\">dict.clear(), dict.copy(), dict.fromkeys(), dict.get(key, default=None), key in dict, dict.items(), dict.keys(), dict.setdefault(key, default=None), dict.update(dict2), dict.values(), pop(key[,default]), popitem()</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"7-Set（集合）\"><a href=\"#7-Set（集合）\" class=\"headerlink\" title=\"7. Set（集合）\"></a>7. Set（集合）</h2><p>无序的不重复元素序列。<br><strong>基本功能是进行成员关系测试或删除重复元素。</strong><br>可以使用 <code>{}</code> 或者 <code>set()</code> 函数创建集合。  </p>\n<blockquote>\n<p>注：创建一个空集合必须使用 <code>set()</code> 而不是 <code>{}</code> ,因为 <code>{}</code> 是用来创建一个空字典。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parame = &#123;value01,value02,...&#125;</span><br><span class=\"line\">或者</span><br><span class=\"line\">set(value)</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"7-1-集合的基本操作\"><a href=\"#7-1-集合的基本操作\" class=\"headerlink\" title=\"7.1 集合的基本操作\"></a>7.1 集合的基本操作</h3><h4 id=\"7-1-1-添加元素\"><a href=\"#7-1-1-添加元素\" class=\"headerlink\" title=\"7.1.1 添加元素\"></a>7.1.1 添加元素</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.add(x), s.update(x)</span><br></pre></td></tr></table></figure>\n<p>将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。<br>区别：<code>s.update(x)</code> 参数可以是列表，元组，字典等，x 可以有多个，用逗号分开。语法格式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))</span><br><span class=\"line\">&gt;&gt;&gt; thisset.update(&#123;1,3&#125;)</span><br><span class=\"line\">&gt;&gt;&gt; print(thisset)</span><br><span class=\"line\">&#123;1, 3, &apos;Google&apos;, &apos;Taobao&apos;, &apos;Runoob&apos;&#125;</span><br><span class=\"line\">&gt;&gt;&gt; thisset.update([1,4],[5,6])  </span><br><span class=\"line\">&gt;&gt;&gt; print(thisset)</span><br><span class=\"line\">&#123;1, 3, 4, 5, 6, &apos;Google&apos;, &apos;Taobao&apos;, &apos;Runoob&apos;&#125;</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-1-2-移除元素\"><a href=\"#7-1-2-移除元素\" class=\"headerlink\" title=\"7.1.2 移除元素\"></a>7.1.2 移除元素</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.remove(x), s.discard(x)</span><br></pre></td></tr></table></figure>\n<p>区别：将元素 x 从集合 s 中移除，如果元素不存在，<code>s.remove(x)</code> 会发生错误，<code>s.discard(x)</code> 不会发生错误。<br>也可设置随机删除集合中的一个元素：<code>s.pop()</code>，在交互模式下，<code>pop</code> 是删除集合的第一个元素（排序后的集合的第一个元素）。  </p>\n<h4 id=\"7-1-3-计算集合元素个数\"><a href=\"#7-1-3-计算集合元素个数\" class=\"headerlink\" title=\"7.1.3 计算集合元素个数\"></a>7.1.3 计算集合元素个数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">len(s)</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-1-4-清空集合\"><a href=\"#7-1-4-清空集合\" class=\"headerlink\" title=\"7.1.4 清空集合\"></a>7.1.4 清空集合</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.clear()</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-1-5-判断元素是否在集合中存在\"><a href=\"#7-1-5-判断元素是否在集合中存在\" class=\"headerlink\" title=\"7.1.5 判断元素是否在集合中存在\"></a>7.1.5 判断元素是否在集合中存在</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x in s</span><br></pre></td></tr></table></figure>\n<p>存在返回 <code>True</code>，不存在返回 <code>False</code>。</p>\n<h3 id=\"7-2-集合内置方法完整列表\"><a href=\"#7-2-集合内置方法完整列表\" class=\"headerlink\" title=\"7.2 集合内置方法完整列表\"></a>7.2 集合内置方法完整列表</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(), clear(), copy(), difference(), difference_update(), discard(), intersection(), intersection_update(), isdisjoint(), issuset(), issuperset(), pop(), remove(), symmetric_difference(), symmetric_difference_update(), union(), update()</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"8-运算符\"><a href=\"#8-运算符\" class=\"headerlink\" title=\"8. 运算符\"></a>8. 运算符</h2><h3 id=\"8-1-算术运算符\"><a href=\"#8-1-算术运算符\" class=\"headerlink\" title=\"8.1 算术运算符\"></a>8.1 算术运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+, -,  /</span><br><span class=\"line\">* 两个数相乘或是返回一个被重复若干次的字符串,</span><br><span class=\"line\">% 返回除法的余数,</span><br><span class=\"line\">** 返回 x 的 y 次幂,</span><br><span class=\"line\">// 向下取接近除数的整数</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-2-比较运算符\"><a href=\"#8-2-比较运算符\" class=\"headerlink\" title=\"8.2 比较运算符\"></a>8.2 比较运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==, !=, &gt;, &lt;, &gt;=, &lt;=</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-3-赋值运算符\"><a href=\"#8-3-赋值运算符\" class=\"headerlink\" title=\"8.3 赋值运算符\"></a>8.3 赋值运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=, +=, -=, *=, /=, %=, **=, //=</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-4-位运算符\"><a href=\"#8-4-位运算符\" class=\"headerlink\" title=\"8.4 位运算符\"></a>8.4 位运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-5-逻辑运算符\"><a href=\"#8-5-逻辑运算符\" class=\"headerlink\" title=\"8.5 逻辑运算符\"></a>8.5 逻辑运算符</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">and, or, not</span><br></pre></td></tr></table></figure>\n<h3 id=\"8-6-成员运算符\"><a href=\"#8-6-成员运算符\" class=\"headerlink\" title=\"8.6 成员运算符\"></a>8.6 成员运算符</h3><p><code>in</code> 如果在指定的序列中找到值返回 <code>True</code>，否则返回 <code>False</code>。<br><code>not in</code> 如果在指定的序列中没有找到值返回 <code>True</code>，否则返回 <code>False</code>。</p>\n<h3 id=\"8-7-身份运算符\"><a href=\"#8-7-身份运算符\" class=\"headerlink\" title=\"8.7 身份运算符\"></a>8.7 身份运算符</h3><p>身份运算符用于比较两个对象的存储单元。<br><code>is</code> 判断两个标识符是不是引用自一个对象。<br><code>is not</code> 判断两个标识符是不是引用自不同对象。<br><code>is</code> 与 <code>==</code> 区别：<br><code>is</code> 用于判断两个变量引用对象是否为同一个，<code>==</code> 用于判断引用变量的值是否相等。</p>\n<h3 id=\"8-8-运算符优先级\"><a href=\"#8-8-运算符优先级\" class=\"headerlink\" title=\"8.8 运算符优先级\"></a>8.8 运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符：<br><img src=\"/2019/01/19/Python3-Basic/OperatorPrecedence.JPG\" alt=\"OperatorPrecedence\"></p>\n<hr>\n<h2 id=\"9-条件控制\"><a href=\"#9-条件控制\" class=\"headerlink\" title=\"9. 条件控制\"></a>9. 条件控制</h2><p>通过一条或多条语句的执行结果（True 或者 False）来决定执行的代码块。</p>\n<h3 id=\"9-1-if-语句\"><a href=\"#9-1-if-语句\" class=\"headerlink\" title=\"9.1 if 语句\"></a>9.1 if 语句</h3><p><code>if - elif - else</code><br>Python 中用 <code>elif</code> 代替了 <code>else if</code>。  </p>\n<blockquote>\n<p>注：<br>每个条件后面要使用冒号 <code>:</code> ，表示接下来是满足条件后要执行的语句块。<br>使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。<br>在 Python 中没有 <code>switch - case</code> 语句。</p>\n</blockquote>\n<h3 id=\"9-2-if-嵌套\"><a href=\"#9-2-if-嵌套\" class=\"headerlink\" title=\"9.2 if 嵌套\"></a>9.2 if 嵌套</h3><p>在嵌套 if 语句中，可以把 if…elif…else 结构放在另外一个 if…elif…else 结构中。</p>\n<hr>\n<h2 id=\"10-循环语句\"><a href=\"#10-循环语句\" class=\"headerlink\" title=\"10. 循环语句\"></a>10. 循环语句</h2><p>只有 <code>for</code> 和 <code>while</code>。  </p>\n<h3 id=\"10-1-while-循环\"><a href=\"#10-1-while-循环\" class=\"headerlink\" title=\"10.1 while 循环\"></a>10.1 while 循环</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while 判断条件：</span><br><span class=\"line\">    语句</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：在 Python 中没有 <code>do... while</code> 循环。</p>\n</blockquote>\n<h4 id=\"10-1-1-无限循环\"><a href=\"#10-1-1-无限循环\" class=\"headerlink\" title=\"10.1.1 无限循环\"></a>10.1.1 无限循环</h4><p>可以通过设置条件表达式永远不为 <code>False</code> 来实现无限循环。  </p>\n<blockquote>\n<p>注：<br>可以使用 CTRL+C 来退出当前的无限循环。<br>无限循环在服务器上客户端的实时请求非常有用。</p>\n</blockquote>\n<h4 id=\"10-1-2-while-循环使用-else-语句\"><a href=\"#10-1-2-while-循环使用-else-语句\" class=\"headerlink\" title=\"10.1.2 while 循环使用 else 语句\"></a>10.1.2 while 循环使用 else 语句</h4><p>在 <code>while...else</code> 在条件语句为 <code>False</code> 时执行 <code>else</code> 的语句块。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">count = 0</span><br><span class=\"line\">while count &lt; 5:</span><br><span class=\"line\">   print (count, &quot; 小于 5&quot;)</span><br><span class=\"line\">   count = count + 1</span><br><span class=\"line\">else:</span><br><span class=\"line\">   print (count, &quot; 大于或等于 5&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">0  小于 5</span><br><span class=\"line\">1  小于 5</span><br><span class=\"line\">2  小于 5</span><br><span class=\"line\">3  小于 5</span><br><span class=\"line\">4  小于 5</span><br><span class=\"line\">5  大于或等于 5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"10-1-3-简单语句组\"><a href=\"#10-1-3-简单语句组\" class=\"headerlink\" title=\"10.1.3 简单语句组\"></a>10.1.3 简单语句组</h4><p>类似 if 语句的语法，如果 while 循环体中只有一条语句，可以将该语句与 while 写在同一行中，例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flag = 1</span><br><span class=\"line\"> </span><br><span class=\"line\">while (flag): print (&apos;欢迎&apos;)</span><br><span class=\"line\"> </span><br><span class=\"line\">print (&quot;Good bye!&quot;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"10-2-for-语句\"><a href=\"#10-2-for-语句\" class=\"headerlink\" title=\"10.2 for 语句\"></a>10.2 for 语句</h3><p>Python for 循环可以遍历任何序列的项目。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for &lt;variable&gt; in &lt;sequence&gt;:</span><br><span class=\"line\">    &lt;statements&gt;</span><br><span class=\"line\">else:</span><br><span class=\"line\">    &lt;statements&gt;</span><br></pre></td></tr></table></figure></p>\n<p>break 语句用于跳出当前循环体：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sites = [&quot;Baidu&quot;, &quot;Google&quot;,&quot;Runoob&quot;,&quot;Taobao&quot;]</span><br><span class=\"line\">for site in sites:</span><br><span class=\"line\">    if site == &quot;Runoob&quot;:</span><br><span class=\"line\">        print(&quot;菜鸟教程!&quot;)</span><br><span class=\"line\">        break</span><br><span class=\"line\">    print(&quot;循环数据 &quot; + site)</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&quot;没有循环数据!&quot;)</span><br><span class=\"line\">print(&quot;完成循环!&quot;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"10-3-range-函数\"><a href=\"#10-3-range-函数\" class=\"headerlink\" title=\"10.3 range() 函数\"></a>10.3 <code>range()</code> 函数</h3><p>内置 <code>range()</code> 函数，可以生成数列。遵循左闭右开原则。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;for i in range(5):</span><br><span class=\"line\">...     print(i)</span><br><span class=\"line\">...</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<p>使用 <code>range</code> 指定区间的值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;for i in range(5,9) :</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\"> </span><br><span class=\"line\">    </span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>也可以使 <code>range</code> 以指定数字开始并指定不同的增量（甚至可以是负数，也叫做“步长”）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;for i in range(0, 10, 3) :</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\"> </span><br><span class=\"line\">    </span><br><span class=\"line\">0</span><br><span class=\"line\">3</span><br><span class=\"line\">6</span><br><span class=\"line\">9</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt;for i in range(-10, -100, -30) :</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\"> </span><br><span class=\"line\">    </span><br><span class=\"line\">-10</span><br><span class=\"line\">-40</span><br><span class=\"line\">-70</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>可以结合 <code>range()</code> 函数和 <code>len()</code> 函数以遍历一个序列的索引，例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;a = [&apos;Google&apos;, &apos;Baidu&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;, &apos;QQ&apos;]</span><br><span class=\"line\">&gt;&gt;&gt; for i in range(len(a)):</span><br><span class=\"line\">...     print(i, a[i])</span><br><span class=\"line\">... </span><br><span class=\"line\">0 Google</span><br><span class=\"line\">1 Baidu</span><br><span class=\"line\">2 Runoob</span><br><span class=\"line\">3 Taobao</span><br><span class=\"line\">4 QQ</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>还可以使用 <code>range()</code> 函数来创建一个列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;list(range(5))</span><br><span class=\"line\">[0, 1, 2, 3, 4]</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"10-4-break-和-continue-语句及循环中的-else-子句\"><a href=\"#10-4-break-和-continue-语句及循环中的-else-子句\" class=\"headerlink\" title=\"10.4 break 和 continue 语句及循环中的 else 子句\"></a>10.4 break 和 continue 语句及循环中的 else 子句</h3><p>break 语句可以跳出 for 和 while 的循环体。如果从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。<br>continue 语句被用来告诉 Python 跳过当前循环快中的剩余语句，然后继续进行下一轮循环。<br>循环语句可以有 else 子句，它在穷尽列表（以 for 循环）或条件变为 false（以 while 循环）导致循环终止时被执行，但循环被 break 终止时不执行。<br>查询质数的循环例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for n in range(2, 10):</span><br><span class=\"line\">    for x in range(2, n):</span><br><span class=\"line\">        if n % x == 0:</span><br><span class=\"line\">            print(n, &apos;等于&apos;, x, &apos;*&apos;, n//x)</span><br><span class=\"line\">            break</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        # 循环中没有找到元素</span><br><span class=\"line\">        print(n, &apos; 是质数&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">2  是质数</span><br><span class=\"line\">3  是质数</span><br><span class=\"line\">4 等于 2 * 2</span><br><span class=\"line\">5  是质数</span><br><span class=\"line\">6 等于 2 * 3</span><br><span class=\"line\">7  是质数</span><br><span class=\"line\">8 等于 2 * 4</span><br><span class=\"line\">9 等于 3 * 3</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"10-5-pass-语句\"><a href=\"#10-5-pass-语句\" class=\"headerlink\" title=\"10.5 pass 语句\"></a>10.5 pass 语句</h3><p>Python <code>pass</code> 是空语句，是为了保持程序结构的完整性。<br><code>pass</code> 不做任何事情，一般用做占位语句。</p>\n<hr>\n<h2 id=\"11-迭代器与生成器\"><a href=\"#11-迭代器与生成器\" class=\"headerlink\" title=\"11. 迭代器与生成器\"></a>11. 迭代器与生成器</h2><h3 id=\"11-1-迭代器\"><a href=\"#11-1-迭代器\" class=\"headerlink\" title=\"11.1 迭代器\"></a>11.1 迭代器</h3><p><strong>迭代</strong>是 Python 最强大的功能之一，是访问集合元素的一种方式。<br><strong>迭代器</strong>是一个可以记住遍历的位置的对象。<br><strong>迭代对象</strong>从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。<br>迭代器有两个基本的方法：<code>iter()</code> 和 <code>next()</code>。<br>字符串、列表或元组对象都可用于创建迭代器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;list=[1,2,3,4]</span><br><span class=\"line\">&gt;&gt;&gt; it = iter(list)    # 创建迭代器对象</span><br><span class=\"line\">&gt;&gt;&gt; print (next(it))   # 输出迭代器的下一个元素</span><br><span class=\"line\">1</span><br><span class=\"line\">&gt;&gt;&gt; print (next(it))</span><br><span class=\"line\">2</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>迭代器对象可以使用常规 <code>for</code> 语句进行遍历：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=[1,2,3,4]</span><br><span class=\"line\">it = iter(list)    # 创建迭代器对象</span><br><span class=\"line\">for x in it:</span><br><span class=\"line\">    print (x, end=&quot; &quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">1 2 3 4</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用 <code>next()</code> 函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sys         # 引入 sys 模块</span><br><span class=\"line\"> </span><br><span class=\"line\">list=[1,2,3,4]</span><br><span class=\"line\">it = iter(list)    # 创建迭代器对象</span><br><span class=\"line\"> </span><br><span class=\"line\">while True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        print (next(it))</span><br><span class=\"line\">    except StopIteration:</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"11-1-1-创建一个迭代器\"><a href=\"#11-1-1-创建一个迭代器\" class=\"headerlink\" title=\"11.1.1 创建一个迭代器\"></a>11.1.1 创建一个迭代器</h4><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code>。<br>Python 的<strong>构造函数</strong>为 <code>__init__()</code>，它会在对象初始化的时候执行。<br><code>__iter__()</code> 方法返回一个特殊的<strong>迭代器对象</strong>，这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。<br><code>__next__()</code> 方法会返回下一个迭代器对象。<br>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyNumbers:</span><br><span class=\"line\">  def __iter__(self):</span><br><span class=\"line\">    self.a = 1</span><br><span class=\"line\">    return self</span><br><span class=\"line\"> </span><br><span class=\"line\">  def __next__(self):</span><br><span class=\"line\">    x = self.a</span><br><span class=\"line\">    self.a += 1</span><br><span class=\"line\">    return x</span><br><span class=\"line\"> </span><br><span class=\"line\">myclass = MyNumbers()</span><br><span class=\"line\">myiter = iter(myclass)</span><br><span class=\"line\"> </span><br><span class=\"line\">print(next(myiter))</span><br><span class=\"line\">print(next(myiter))</span><br><span class=\"line\">print(next(myiter))</span><br><span class=\"line\">print(next(myiter))</span><br><span class=\"line\">print(next(myiter))</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"11-1-2-StopIteration\"><a href=\"#11-1-2-StopIteration\" class=\"headerlink\" title=\"11.1.2 StopIteration\"></a>11.1.2 StopIteration</h4><p><code>StopIteration</code> 异常用于标识迭代的完成，防止出现无限循环的情况，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。<br>在 20 次迭代后停止执行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyNumbers:</span><br><span class=\"line\">  def __iter__(self):</span><br><span class=\"line\">    self.a = 1</span><br><span class=\"line\">    return self</span><br><span class=\"line\"> </span><br><span class=\"line\">  def __next__(self):</span><br><span class=\"line\">    if self.a &lt;= 20:</span><br><span class=\"line\">      x = self.a</span><br><span class=\"line\">      self.a += 1</span><br><span class=\"line\">      return x</span><br><span class=\"line\">    else:</span><br><span class=\"line\">      raise StopIteration</span><br><span class=\"line\"> </span><br><span class=\"line\">myclass = MyNumbers()</span><br><span class=\"line\">myiter = iter(myclass)</span><br><span class=\"line\"> </span><br><span class=\"line\">for x in myiter:</span><br><span class=\"line\">  print(x)</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"11-2-生成器\"><a href=\"#11-2-生成器\" class=\"headerlink\" title=\"11.2 生成器\"></a>11.2 生成器</h3><p>在 Python 中，使用了 <code>yield</code> 的函数被称为生成器（generator）。<br>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作。<br>在调用生成器运行的过程中，每次遇到 <code>yield</code> 时函数会暂停并保存当前所有的运行信息，返回 <code>yield</code> 的值，并在下一次执行 <code>next()</code> 方法时从当前位置继续运行。  </p>\n<blockquote>\n<p>注：调用一个生成器函数，返回的是一个迭代器对象。</p>\n</blockquote>\n<p>以下实例使用 <code>yield</code> 实现斐波那契数列：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sys</span><br><span class=\"line\"> </span><br><span class=\"line\">def fibonacci(n): # 生成器函数 - 斐波那契</span><br><span class=\"line\">    a, b, counter = 0, 1, 0</span><br><span class=\"line\">    while True:</span><br><span class=\"line\">        if (counter &gt; n): </span><br><span class=\"line\">            return</span><br><span class=\"line\">        yield a</span><br><span class=\"line\">        a, b = b, a + b</span><br><span class=\"line\">        counter += 1</span><br><span class=\"line\">f = fibonacci(10) # f 是一个迭代器，由生成器返回生成</span><br><span class=\"line\"> </span><br><span class=\"line\">while True:</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        print (next(f), end=&quot; &quot;)</span><br><span class=\"line\">    except StopIteration:</span><br><span class=\"line\">        sys.exit()</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"12-函数\"><a href=\"#12-函数\" class=\"headerlink\" title=\"12. 函数\"></a>12. 函数</h2><p>函数是组织好的，可重复使用的，用来实现单一或相关联功能的代码段。</p>\n<h3 id=\"12-1-定义一个函数\"><a href=\"#12-1-定义一个函数\" class=\"headerlink\" title=\"12.1 定义一个函数\"></a>12.1 定义一个函数</h3><p>规则：<br>函数代码块以 <code>def</code> 关键词开头，后接函数标识符名称和圆括号 <code>()</code>。<br>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。<br>函数的第一行语句可以选择性地使用文档字符串——用于存放函数说明。<br>函数内容以冒号起始，并且缩进。<br><code>return [表达式]</code> 结束函数，选择性地返回一个值给调用方。不带表达式的 <code>return</code> 相当于返回 <code>None</code>。</p>\n<h3 id=\"12-2-语法\"><a href=\"#12-2-语法\" class=\"headerlink\" title=\"12.2 语法\"></a>12.2 语法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def 函数名(参数列表):</span><br><span class=\"line\">    函数体</span><br></pre></td></tr></table></figure>\n<h3 id=\"12-3-参数传递\"><a href=\"#12-3-参数传递\" class=\"headerlink\" title=\"12.3 参数传递\"></a>12.3 参数传递</h3><p>在 Python 中，类型属于对象，变量是没有类型的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=[1,2,3]</span><br><span class=\"line\">a=&quot;Runoob&quot;</span><br></pre></td></tr></table></figure></p>\n<p>以上代码中，[1, 2, 3] 是 List 类型，<code>&quot;Runoob&quot;</code> 是 <code>String</code> 类型，而变量 <code>a</code> 是没有类型，它仅仅是一个对象的引用（一个指针），可以是指向 <code>List</code> 类型对象，也可以是指向 <code>String</code> 类型对象。</p>\n<h4 id=\"12-3-1-可更改（mutable）与不可更改（immutable）对象\"><a href=\"#12-3-1-可更改（mutable）与不可更改（immutable）对象\" class=\"headerlink\" title=\"12.3.1 可更改（mutable）与不可更改（immutable）对象\"></a>12.3.1 可更改（mutable）与不可更改（immutable）对象</h4><p>在 Python 中，<code>String、Number 和 Tuple</code> 是不可更改的对象，而 <code>List、Dictionary 和 Set</code> 等则是可以更改的对象。<br><strong>不可变类型：</strong>变量赋值 <code>a = 5</code> 后再赋值 <code>a = 10</code>，这里实际是新生成一个 <code>int</code> 值对象 <code>10</code>，再让 <code>a</code> 指向它，而 <code>5</code> 被丢弃，不是改变 <code>a</code> 的值，相当于新生成了 <code>a</code>。<br><strong>可变类型：</strong>变量赋值 <code>la = [1, 2, 3, 4]</code> 后再赋值 <code>la[2] = 5</code> 则是将 <code>list la</code> 的第三个元素值更改，本身 <code>la</code> 没有动，只是其内部的一部分值被修改了。<br>Python 函数的参数传递：<br><strong>不可变类型：</strong>传递的只是 <code>a</code> 的值，没有影响 <code>a</code> 对象本身。比如再 <code>fun(a)</code> 内部修改 <code>a</code> 的值，只是修改另一个复制的对象，不会影响 <code>a</code> 本身。<br><strong>可变类型：</strong>引用传递，将 <code>la</code> 真正的传过去，修改后 <code>fun</code> 外部的 <code>la</code> 也会受影响。  </p>\n<blockquote>\n<p>注：Python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>\n</blockquote>\n<h3 id=\"12-4-参数\"><a href=\"#12-4-参数\" class=\"headerlink\" title=\"12.4 参数\"></a>12.4 参数</h3><h4 id=\"12-4-1-必需参数\"><a href=\"#12-4-1-必需参数\" class=\"headerlink\" title=\"12.4.1 必需参数\"></a>12.4.1 必需参数</h4><p>必需参数必须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>\n<h4 id=\"12-4-2-关键字参数\"><a href=\"#12-4-2-关键字参数\" class=\"headerlink\" title=\"12.4.2 关键字参数\"></a>12.4.2 关键字参数</h4><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。<br>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#可写函数说明</span><br><span class=\"line\">def printme( str ):</span><br><span class=\"line\">   &quot;打印任何传入的字符串&quot;</span><br><span class=\"line\">   print (str)</span><br><span class=\"line\">   return</span><br><span class=\"line\"> </span><br><span class=\"line\">#调用printme函数</span><br><span class=\"line\">printme( str = &quot;ywang&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">ywang</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"12-4-3-默认参数\"><a href=\"#12-4-3-默认参数\" class=\"headerlink\" title=\"12.4.3 默认参数\"></a>12.4.3 默认参数</h4><p>调用函数时，如果没有传递参数，则会使用默认参数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printinfo( name, age = 35 ):</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"12-4-4-不定长参数\"><a href=\"#12-4-4-不定长参数\" class=\"headerlink\" title=\"12.4.4 不定长参数\"></a>12.4.4 不定长参数</h4><p>当需要函数处理比当初声明时更多的参数，这些参数叫做不定长参数。<br>语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def functionname([formal_args,] *var_args_tuple ):</span><br><span class=\"line\">   &quot;函数_文档字符串&quot;</span><br><span class=\"line\">   function_suite</span><br><span class=\"line\">   return [expression]</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注：加了 * 的参数会以元组（tuple）的形式导入，存放所有未命名的变量参数。<br>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。<br>还有一种是参数带两个星号 ** ，语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def functionname([formal_args,] **var_args_dict ):</span><br><span class=\"line\">   &quot;函数_文档字符串&quot;</span><br><span class=\"line\">   function_suite</span><br><span class=\"line\">   return [expression]</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>加了两个星号 ** 的参数会以字典的形式导入。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def printinfo( arg1, **vardict ):</span><br><span class=\"line\"># 调用printinfo 函数</span><br><span class=\"line\">printinfo(1, a=2,b=3)</span><br></pre></td></tr></table></figure></p>\n<p>声明函数时，参数中 * 可以单独出现，例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def f(a,b,*,c):</span><br><span class=\"line\">    return a+b+c</span><br></pre></td></tr></table></figure></p>\n<p>如果单独出现 <em> ，</em> 后的参数必须用关键字传入。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def f(a,b,*,c):</span><br><span class=\"line\">f(1,2,3)   # 报错</span><br><span class=\"line\">f(1,2,c=3) # 正常</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"12-5-匿名函数\"><a href=\"#12-5-匿名函数\" class=\"headerlink\" title=\"12.5 匿名函数\"></a>12.5 匿名函数</h3><p>使用 <code>lambda</code> 来创建匿名函数。<br><code>lambda</code> 只是一个表达式，而不是一个代码块。函数体比 <code>def</code> 简单很多，仅仅能封装有限的逻辑进去。<br><code>lambda</code> 的函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。<br>语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lambda [arg1 [,arg2,.....argn]]:expression</span><br><span class=\"line\"></span><br><span class=\"line\">sum = lambda arg1, arg2: arg1 + arg2</span><br><span class=\"line\">print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"12-6-return-语句\"><a href=\"#12-6-return-语句\" class=\"headerlink\" title=\"12.6 return 语句\"></a>12.6 return 语句</h3><p>不带参数的 <code>return</code> 返回 <code>None</code>。</p>\n<h3 id=\"12-7-变量作用域\"><a href=\"#12-7-变量作用域\" class=\"headerlink\" title=\"12.7 变量作用域\"></a>12.7 变量作用域</h3><p>L（Local）局部作用域<br>E（Enclosing）闭包函数外的函数中<br>G（Global）全局作用域<br>B（Built-in）内建作用域<br><strong>以 L -&gt; E -&gt; G -&gt; B 的规则查找。</strong><br>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域。  </p>\n<blockquote>\n<p>注：Python 在启动时会自动为我们载入很多内建的函数、类。这些内建模块的命名空间就是内建作用域。</p>\n</blockquote>\n<p>当内部作用域想修改全局作用域中变量时，使用 <code>global</code> 关键字。<br>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 <code>nonlocal</code> 关键字。</p>\n<hr>\n<h2 id=\"13-Python3-的数据结构\"><a href=\"#13-Python3-的数据结构\" class=\"headerlink\" title=\"13. Python3 的数据结构\"></a>13. Python3 的数据结构</h2><h3 id=\"13-1-把列表当作堆栈（后进先出）使用\"><a href=\"#13-1-把列表当作堆栈（后进先出）使用\" class=\"headerlink\" title=\"13.1 把列表当作堆栈（后进先出）使用\"></a>13.1 把列表当作堆栈（后进先出）使用</h3><p>用 <code>append()</code> 方法可以把一个元素添加到堆栈顶。<br>用不指定索引的 <code>pop()</code> 方法可以把一个元素从堆栈顶释放出来。</p>\n<h3 id=\"13-2-把列表当作队列（先进先出）使用\"><a href=\"#13-2-把列表当作队列（先进先出）使用\" class=\"headerlink\" title=\"13.2 把列表当作队列（先进先出）使用\"></a>13.2 把列表当作队列（先进先出）使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">append(), popleft()</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-2-列表推导式\"><a href=\"#13-2-列表推导式\" class=\"headerlink\" title=\"13.2 列表推导式\"></a>13.2 列表推导式</h3><p>列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判断条件创建子序列。<br>每个列表推导式都在 <code>for</code> 之后跟一个表达式，然后有零到多个 <code>for</code> 或 <code>if</code> 子句。返回结果是一个根据表达式从其后的 <code>for</code> 和 <code>if</code> 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。<br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; vec = [2, 4, 6]</span><br><span class=\"line\">&gt;&gt;&gt; [3*x for x in vec]</span><br><span class=\"line\">[6, 12, 18]</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; [[x, x**2] for x in vec]</span><br><span class=\"line\">[[2, 4], [4, 16], [6, 36]]</span><br><span class=\"line\"></span><br><span class=\"line\">#  用 if 子句作为过滤器</span><br><span class=\"line\">&gt;&gt;&gt; [3*x for x in vec if x &gt; 3]</span><br><span class=\"line\">[12, 18]</span><br><span class=\"line\">&gt;&gt;&gt; [3*x for x in vec if x &lt; 2]</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure></p>\n<p>列表推导式可以使用复杂表达式或嵌套函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; [str(round(355/113, i)) for i in range(1, 6)]</span><br><span class=\"line\">[&apos;3.1&apos;, &apos;3.14&apos;, &apos;3.142&apos;, &apos;3.1416&apos;, &apos;3.14159&apos;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"13-3-嵌套列表解析\"><a href=\"#13-3-嵌套列表解析\" class=\"headerlink\" title=\"13.3 嵌套列表解析\"></a>13.3 嵌套列表解析</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 3 * 4 的矩阵列表</span><br><span class=\"line\">&gt;&gt;&gt; matrix = [</span><br><span class=\"line\">...     [1, 2, 3, 4],</span><br><span class=\"line\">...     [5, 6, 7, 8],</span><br><span class=\"line\">...     [9, 10, 11, 12],</span><br><span class=\"line\">... ]</span><br><span class=\"line\"></span><br><span class=\"line\"># 将 3 * 4 的矩阵列表转换为 4 * 3 列表</span><br><span class=\"line\">&gt;&gt;&gt; [[row[i] for row in matrix] for i in range(4)]</span><br><span class=\"line\">[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br><span class=\"line\"></span><br><span class=\"line\"># 等价于</span><br><span class=\"line\">&gt;&gt;&gt; transposed = []</span><br><span class=\"line\">&gt;&gt;&gt; for i in range(4):</span><br><span class=\"line\">...     # the following 3 lines implement the nested listcomp</span><br><span class=\"line\">...     transposed_row = []</span><br><span class=\"line\">...     for row in matrix:</span><br><span class=\"line\">...         transposed_row.append(row[i])</span><br><span class=\"line\">...     transposed.append(transposed_row)</span><br><span class=\"line\">...</span><br><span class=\"line\">&gt;&gt;&gt; transposed</span><br><span class=\"line\">[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]</span><br></pre></td></tr></table></figure>\n<h3 id=\"13-4-del-语句\"><a href=\"#13-4-del-语句\" class=\"headerlink\" title=\"13.4 del 语句\"></a>13.4 del 语句</h3><p>使用 <code>del</code> 语句可以从一个列表中依索引而不是一个值来删除一个元素。<br>可以用 <code>del</code> 语句从列表中删除一个切割，或清空整个列表。<br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a = [-1, 1, 66.25, 333, 333, 1234.5]</span><br><span class=\"line\">&gt;&gt;&gt; del a[0]</span><br><span class=\"line\">&gt;&gt;&gt; a</span><br><span class=\"line\">[1, 66.25, 333, 333, 1234.5]</span><br><span class=\"line\">&gt;&gt;&gt; del a[2:4]</span><br><span class=\"line\">&gt;&gt;&gt; a</span><br><span class=\"line\">[1, 66.25, 1234.5]</span><br><span class=\"line\">&gt;&gt;&gt; del a[:]</span><br><span class=\"line\">&gt;&gt;&gt; a</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure></p>\n<p>也可以用 del 删除实体变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; del a</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"13-5-元组和序列\"><a href=\"#13-5-元组和序列\" class=\"headerlink\" title=\"13.5 元组和序列\"></a>13.5 元组和序列</h3><p>元组由若干逗号分隔的值组成，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; t = 12345, 54321, &apos;hello!&apos;</span><br><span class=\"line\">&gt;&gt;&gt; t[0]</span><br><span class=\"line\">12345</span><br><span class=\"line\">&gt;&gt;&gt; t</span><br><span class=\"line\">(12345, 54321, &apos;hello!&apos;)</span><br><span class=\"line\">&gt;&gt;&gt; # Tuples may be nested:</span><br><span class=\"line\">... u = t, (1, 2, 3, 4, 5)</span><br><span class=\"line\">&gt;&gt;&gt; u</span><br><span class=\"line\">((12345, 54321, &apos;hello!&apos;), (1, 2, 3, 4, 5))</span><br></pre></td></tr></table></figure></p>\n<p>元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号，不过括号通常是必须的。</p>\n<h3 id=\"13-6-集合\"><a href=\"#13-6-集合\" class=\"headerlink\" title=\"13.6 集合\"></a>13.6 集合</h3><p>集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。<br>集合也支持推导式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; a = &#123;x for x in &apos;abracadabra&apos; if x not in &apos;abc&apos;&#125;</span><br><span class=\"line\">&gt;&gt;&gt; a</span><br><span class=\"line\">&#123;&apos;r&apos;, &apos;d&apos;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"13-7-字典\"><a href=\"#13-7-字典\" class=\"headerlink\" title=\"13.7 字典\"></a>13.7 字典</h3><p>序列是以连续的整数为索引，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。<br>构造函数 <code>dict()</code> 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; dict([(&apos;sape&apos;, 4139), (&apos;guido&apos;, 4127), (&apos;jack&apos;, 4098)])</span><br><span class=\"line\">&#123;&apos;sape&apos;: 4139, &apos;jack&apos;: 4098, &apos;guido&apos;: 4127&#125;</span><br></pre></td></tr></table></figure></p>\n<p>字典推导式可以用来创建任意键和值的表达式词典：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class=\"line\">&#123;2: 4, 4: 16, 6: 36&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"13-8-遍历技巧\"><a href=\"#13-8-遍历技巧\" class=\"headerlink\" title=\"13.8 遍历技巧\"></a>13.8 遍历技巧</h3><h4 id=\"13-8-1-在字典中遍历时，关键字和对应的值可以使用-items-方法同时解读出来\"><a href=\"#13-8-1-在字典中遍历时，关键字和对应的值可以使用-items-方法同时解读出来\" class=\"headerlink\" title=\"13.8.1 在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来\"></a>13.8.1 在字典中遍历时，关键字和对应的值可以使用 <code>items()</code> 方法同时解读出来</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; knights = &#123;&apos;gallahad&apos;: &apos;the pure&apos;, &apos;robin&apos;: &apos;the brave&apos;&#125;</span><br><span class=\"line\">&gt;&gt;&gt; for k, v in knights.items():</span><br><span class=\"line\">...     print(k, v)</span><br><span class=\"line\">...</span><br><span class=\"line\">gallahad the pure</span><br><span class=\"line\">robin the brave</span><br></pre></td></tr></table></figure>\n<h4 id=\"13-8-2-在序列中遍历时，索引位置和对应值可以使用-enumerate-函数同时得到\"><a href=\"#13-8-2-在序列中遍历时，索引位置和对应值可以使用-enumerate-函数同时得到\" class=\"headerlink\" title=\"13.8.2 在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到\"></a>13.8.2 在序列中遍历时，索引位置和对应值可以使用 <code>enumerate()</code> 函数同时得到</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; for i, v in enumerate([&apos;tic&apos;, &apos;tac&apos;, &apos;toe&apos;]):</span><br><span class=\"line\">...     print(i, v)</span><br><span class=\"line\">...</span><br><span class=\"line\">0 tic</span><br><span class=\"line\">1 tac</span><br><span class=\"line\">2 toe</span><br></pre></td></tr></table></figure>\n<h4 id=\"13-8-3-同时遍历两个或更多的序列，可以使用-zip-组合\"><a href=\"#13-8-3-同时遍历两个或更多的序列，可以使用-zip-组合\" class=\"headerlink\" title=\"13.8.3 同时遍历两个或更多的序列，可以使用 zip() 组合\"></a>13.8.3 同时遍历两个或更多的序列，可以使用 <code>zip()</code> 组合</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; questions = [&apos;name&apos;, &apos;quest&apos;, &apos;favorite color&apos;]</span><br><span class=\"line\">&gt;&gt;&gt; answers = [&apos;lancelot&apos;, &apos;the holy grail&apos;, &apos;blue&apos;]</span><br><span class=\"line\">&gt;&gt;&gt; for q, a in zip(questions, answers):</span><br><span class=\"line\">...     print(&apos;What is your &#123;0&#125;?  It is &#123;1&#125;.&apos;.format(q, a))</span><br><span class=\"line\">...</span><br><span class=\"line\">What is your name?  It is lancelot.</span><br><span class=\"line\">What is your quest?  It is the holy grail.</span><br><span class=\"line\">What is your favorite color?  It is blue.</span><br></pre></td></tr></table></figure>\n<h4 id=\"13-8-4-要反向遍历一个序列，首先指定整个序列，然后调用-reversed-函数\"><a href=\"#13-8-4-要反向遍历一个序列，首先指定整个序列，然后调用-reversed-函数\" class=\"headerlink\" title=\"13.8.4 要反向遍历一个序列，首先指定整个序列，然后调用 reversed() 函数\"></a>13.8.4 要反向遍历一个序列，首先指定整个序列，然后调用 <code>reversed()</code> 函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ra = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class=\"line\">&gt;&gt;&gt; for i in reversed(ra):</span><br><span class=\"line\">\tprint(i)</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">9</span><br><span class=\"line\">8</span><br><span class=\"line\">7</span><br><span class=\"line\">6</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<h4 id=\"13-8-5-要按顺序遍历一个序列，使用-sorted-函数返回一个已排序的序列，并不修改原值\"><a href=\"#13-8-5-要按顺序遍历一个序列，使用-sorted-函数返回一个已排序的序列，并不修改原值\" class=\"headerlink\" title=\"13.8.5 要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值\"></a>13.8.5 要按顺序遍历一个序列，使用 <code>sorted()</code> 函数返回一个已排序的序列，并不修改原值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> lB = [4, 5, 3]</span><br><span class=\"line\">&gt;&gt;&gt; for i in sorted(lB):</span><br><span class=\"line\">\tprint(i)</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"14-模块\"><a href=\"#14-模块\" class=\"headerlink\" title=\"14. 模块\"></a>14. 模块</h2><p>我们脚本上是用 Python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有方法和变量就都消失了。为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互模式的解释器实例使用，这个文件被成为模块。<br>模块时一个包含所有你定义的函数和变量的文件，其后缀名是 <strong>.py</strong>。模块以可被别的程序引入，以使用该模块中的函数等功能。这也是使用 Python 标准库的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  sys.path 包含一个 Python 解释器自动查找所需模块的路径列表</span><br><span class=\"line\">&gt;&gt;&gt; import sys</span><br><span class=\"line\">&gt;&gt;&gt; sys.path</span><br><span class=\"line\">[&apos;&apos;, &apos;C:\\\\Users\\\\ywang\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\Lib\\\\idlelib&apos;, &apos;C:\\\\Users\\\\ywang\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\python37.zip&apos;, &apos;C:\\\\Users\\\\ywang\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\DLLs&apos;, &apos;C:\\\\Users\\\\ywang\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib&apos;, &apos;C:\\\\Users\\\\ywang\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37&apos;, &apos;C:\\\\Users\\\\ywang\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python37\\\\lib\\\\site-packages&apos;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"14-1-import-语句\"><a href=\"#14-1-import-语句\" class=\"headerlink\" title=\"14.1 import 语句\"></a>14.1 import 语句</h3><p>想要使用 Python 源文件，只需要在另一个源文件例执行 <code>import</code> 语句。一个模块只会被导入一次，不管你执行了多少次 <code>import</code>。这样可以防止导入模块被一遍又一遍地执行。语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import module1[, module2[,... moduleN]</span><br></pre></td></tr></table></figure></p>\n<p>当解释器遇到 <code>import</code> 语句，如果模块在当前的搜索路径就会被导入。<br>搜索路径是一个解释器会先进行搜索的所有目录的列表。<br>搜索路径是在 Python 编译或安装地时候确定地，安装新的库应该也会被修改。搜索路径被存储在 <code>sys</code> 模块中的 <code>path</code> 变量。<br><code>sys.path</code> 输出是一个列表，其中第一项是空串，代表当前目录，亦即我们执行 Python 解释器的目录（遂于脚本的话就是运行的脚本所在的目录）。<br>了解了搜索路径的概念，就可以在脚本中修改 <code>sys.path</code> 来引入一些不在搜索路径中的模块。<br>使用模块名称来访问函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 导入模块</span><br><span class=\"line\">import support</span><br><span class=\"line\"> </span><br><span class=\"line\"># 现在可以调用模块里包含的函数了</span><br><span class=\"line\">support.print_func(&quot;Runoob&quot;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"14-2-from…import-语句\"><a href=\"#14-2-from…import-语句\" class=\"headerlink\" title=\"14.2 from…import 语句\"></a>14.2 from…import 语句</h3><p>从模块中导入一个指定的部分到当前命名空间中。语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from modname import name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"14-3-from…import-语句\"><a href=\"#14-3-from…import-语句\" class=\"headerlink\" title=\"14.3 from…import * 语句\"></a>14.3 from…import * 语句</h3><p>把一个模块的所有内容全部导入到当前的命名空间也是可行的，只需使用如下声明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from modname import *</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"14-3-深入模块\"><a href=\"#14-3-深入模块\" class=\"headerlink\" title=\"14.3 深入模块\"></a>14.3 深入模块</h3><p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块，只有在第一次被导入时才会被执行。<br>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from fibo import fib, fib2</span><br><span class=\"line\">&gt;&gt;&gt; fib(500)</span><br><span class=\"line\">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure></p>\n<p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中。<br>所以在这个例子里面，<code>fibo</code> 这个名称是没有定义的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from fibo import *</span><br><span class=\"line\">&gt;&gt;&gt; fib(500)</span><br><span class=\"line\">1 1 2 3 5 8 13 21 34 55 89 144 233 377</span><br></pre></td></tr></table></figure></p>\n<p>这种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表。但是那些由单一下划线 <code>_</code> 开头的名字不在此列。不推荐使用此方法，因为引入的其他来源的命名，很可能覆盖了已有的定义。</p>\n<h3 id=\"14-4-name-属性\"><a href=\"#14-4-name-属性\" class=\"headerlink\" title=\"14.4 name 属性\"></a>14.4 <strong>name</strong> 属性</h3><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用 <code>__name__</code> 属性来使该程序块仅在该模块自身运行时执行。<br><strong>每个模块都有一个 <code>__name__</code> 属性，当其值是 <code>__main__</code> 时，表明该模块自身在运行，否则是被引入。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Filename: using_name.py</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ == &apos;__main__&apos;:</span><br><span class=\"line\">   print(&apos;程序自身在运行&apos;)</span><br><span class=\"line\">else:</span><br><span class=\"line\">   print(&apos;我来自另一模块&apos;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"14-5-dir-函数\"><a href=\"#14-5-dir-函数\" class=\"headerlink\" title=\"14.5 dir() 函数\"></a>14.5 dir() 函数</h3><p>内置的 <code>dir()</code> 函数可以找到模块内定义的所有名称，以一个字符串列表的形式返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; dir(sys)  </span><br><span class=\"line\">[&apos;__displayhook__&apos;, &apos;__doc__&apos;, &apos;__excepthook__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;,</span><br><span class=\"line\"> &apos;__package__&apos;, &apos;__stderr__&apos;, &apos;__stdin__&apos;, &apos;__stdout__&apos;,</span><br><span class=\"line\"> &apos;_clear_type_cache&apos;, &apos;_current_frames&apos;, &apos;_debugmallocstats&apos;, &apos;_getframe&apos;,</span><br><span class=\"line\"> &apos;_home&apos;, &apos;_mercurial&apos;, &apos;_xoptions&apos;, &apos;abiflags&apos;, &apos;api_version&apos;, &apos;argv&apos;,</span><br><span class=\"line\"> &apos;base_exec_prefix&apos;, &apos;base_prefix&apos;, &apos;builtin_module_names&apos;, &apos;byteorder&apos;,</span><br><span class=\"line\"> &apos;call_tracing&apos;, &apos;callstats&apos;, &apos;copyright&apos;, &apos;displayhook&apos;,</span><br><span class=\"line\"> &apos;dont_write_bytecode&apos;, &apos;exc_info&apos;, &apos;excepthook&apos;, &apos;exec_prefix&apos;,</span><br><span class=\"line\"> &apos;executable&apos;, &apos;exit&apos;, &apos;flags&apos;, &apos;float_info&apos;, &apos;float_repr_style&apos;,</span><br><span class=\"line\"> &apos;getcheckinterval&apos;, &apos;getdefaultencoding&apos;, &apos;getdlopenflags&apos;,</span><br><span class=\"line\"> &apos;getfilesystemencoding&apos;, &apos;getobjects&apos;, &apos;getprofile&apos;, &apos;getrecursionlimit&apos;,</span><br><span class=\"line\"> &apos;getrefcount&apos;, &apos;getsizeof&apos;, &apos;getswitchinterval&apos;, &apos;gettotalrefcount&apos;,</span><br><span class=\"line\"> &apos;gettrace&apos;, &apos;hash_info&apos;, &apos;hexversion&apos;, &apos;implementation&apos;, &apos;int_info&apos;,</span><br><span class=\"line\"> &apos;intern&apos;, &apos;maxsize&apos;, &apos;maxunicode&apos;, &apos;meta_path&apos;, &apos;modules&apos;, &apos;path&apos;,</span><br><span class=\"line\"> &apos;path_hooks&apos;, &apos;path_importer_cache&apos;, &apos;platform&apos;, &apos;prefix&apos;, &apos;ps1&apos;,</span><br><span class=\"line\"> &apos;setcheckinterval&apos;, &apos;setdlopenflags&apos;, &apos;setprofile&apos;, &apos;setrecursionlimit&apos;,</span><br><span class=\"line\"> &apos;setswitchinterval&apos;, &apos;settrace&apos;, &apos;stderr&apos;, &apos;stdin&apos;, &apos;stdout&apos;,</span><br><span class=\"line\"> &apos;thread_info&apos;, &apos;version&apos;, &apos;version_info&apos;, &apos;warnoptions&apos;]</span><br></pre></td></tr></table></figure></p>\n<p>如果没有给定参数，那么 <code>dir()</code> 函数会罗列出当前定义的所有名称。</p>\n<h3 id=\"14-6-标准模块\"><a href=\"#14-6-标准模块\" class=\"headerlink\" title=\"14.6 标准模块\"></a>14.6 标准模块</h3><p>Python 本身带着一些标准的模块库，有些模块直接被构建在解析器例，这些虽然不是语言内置的功能，但它却能很高效的使用，甚至是系统调用也没问题。<br>这些组件会根据不同的操作系统进行不同形式的配置，比如 <code>winreg</code> 这个模块就只会提供给 <code>Windows</code> 系统。<br>有个特殊的模块 <code>sys</code>，它内置在每一个 <code>Python</code> 解析器中。</p>\n<h3 id=\"14-7-包\"><a href=\"#14-7-包\" class=\"headerlink\" title=\"14.7 包\"></a>14.7 包</h3><p>包是一种管理 Python 模块命名空间的形式，采用“点模块名称”。比如一个模块的名称是 A.B，那么它标识一个包 A 中的子模块 B。<br>就像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。<br>在导入一个包的时候，Python 会根据 <code>sys.path</code> 中的目录来寻找这个包中包含的子目录。<br>目录只有包含一个叫做 <strong><strong>init</strong>.py</strong> 的文件才会被认作是一个包，主要是为了避免一些烂俗的名字（比如 String）不小心影响搜索路径中的有效模块。最简单的情况，放一个空的文件 <strong><strong>init</strong>.py</strong> 就可以了。当然这个文件中也可以包含一些初始化代码或者为 <code>__all__</code> 变量赋值。<br>用户可以每次只导入一个包里面的特定模块，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sound.effects.echo</span><br></pre></td></tr></table></figure></p>\n<p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure></p>\n<p>还有一种导入子模块的方法是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sound.effects import echo</span><br></pre></td></tr></table></figure></p>\n<p>这同样会导入子模块: echo，并且不需要那些冗长的前缀，所以可以这样使用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo.echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure></p>\n<p>还有一种变化就是直接导入一个函数或者变量:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sound.effects.echo import echofilter</span><br></pre></td></tr></table></figure></p>\n<p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 <code>echofilter()</code> 函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echofilter(input, output, delay=0.7, atten=4)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"14-8-从一个包中导入\"><a href=\"#14-8-从一个包中导入\" class=\"headerlink\" title=\"14.8 从一个包中导入 *\"></a>14.8 从一个包中导入 *</h3><p>如果包定义文件 <strong><strong>init</strong>.py</strong> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 <code>from package import *</code> 的时候就把这个列表中的所有名字作为包内容导入。  </p>\n<blockquote>\n<p>注：作为包的作者，更新包之后记得 <code>__all__</code> 也更新。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]</span><br></pre></td></tr></table></figure>\n<p>这表示当使用 <code>from sound.effects import *</code> 这种用法时，只会导入包里面这三个子模块。</p>\n<hr>\n<h2 id=\"15-输入和输出\"><a href=\"#15-输入和输出\" class=\"headerlink\" title=\"15. 输入和输出\"></a>15. 输入和输出</h2><h3 id=\"15-1-输出格式美化\"><a href=\"#15-1-输出格式美化\" class=\"headerlink\" title=\"15.1 输出格式美化\"></a>15.1 输出格式美化</h3><p><code>print()</code> 函数、表达式语句和文件对象操作。</p>\n<h3 id=\"15-1-str-repr\"><a href=\"#15-1-str-repr\" class=\"headerlink\" title=\"15.1 str(), repr()\"></a>15.1 str(), repr()</h3><p><code>str()</code> 返回一个用户易读的表达形式。<br><code>repr()</code> 产生一个解释器易读读的表达形式。</p>\n<h4 id=\"15-1-1-rjust-ljust-center\"><a href=\"#15-1-1-rjust-ljust-center\" class=\"headerlink\" title=\"15.1.1 rjust(), ljust(), center()\"></a>15.1.1 rjust(), ljust(), center()</h4><p>语法：<code>str(data).rjust(n), repr(data).rjust(n)</code><br><code>n</code> 为一共占几位，无字符部分填充空格。<code>rjust()</code> 为字符靠右对齐，<code>ljust()</code> 为字符靠左对齐，<code>center()</code> 为字符居中对齐。</p>\n<h3 id=\"15-2-zfill\"><a href=\"#15-2-zfill\" class=\"headerlink\" title=\"15.2 zfill()\"></a>15.2 zfill()</h3><p>语法：<code>&#39;number&#39;.zfill(n)</code><br>在数字左边填充 0</p>\n<h3 id=\"15-3-format\"><a href=\"#15-3-format\" class=\"headerlink\" title=\"15.3 format()\"></a>15.3 format()</h3><p>语法：<code>print(&#39;{}[,{}...]&#39;.format(&#39;&#39;,[,&#39;&#39;..]))</code><br><code>{}</code> 及其里面的字符（称作格式化字段）将会被 <code>format()</code> 中的参数替换。<br><code>{}</code> 中的数字用于指向传入对象在 <code>format()</code> 中的位置。<br>如果在 <code>format()</code> 中使用了关键字参数，那么它们的值会指向使用该名字的参数。<br>位置及关键字可以任意的结合。<br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; print(&apos;站点列表 &#123;0&#125;, &#123;1&#125;, 和 &#123;other&#125;。&apos;.format(&apos;Google&apos;, &apos;Runoob&apos;,</span><br><span class=\"line\">                                                       other=&apos;Taobao&apos;))</span><br><span class=\"line\">站点列表 Google, Runoob, 和 Taobao。</span><br></pre></td></tr></table></figure></p>\n<p><code>&#39;!a&#39;</code> - 使用 <code>ascii()</code>, <code>&#39;!s&#39;</code> - 使用 <code>str()</code>, <code>&#39;!r&#39;</code> 使用 <code>repr()</code> 可以在格式化某个值之前对其进行转化。<br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; import math</span><br><span class=\"line\">&gt;&gt;&gt; print(&apos;常量 PI 的值近似为： &#123;&#125;。&apos;.format(math.pi))</span><br><span class=\"line\">常量 PI 的值近似为： 3.141592653589793。</span><br><span class=\"line\">&gt;&gt;&gt; print(&apos;常量 PI 的值近似为： &#123;!r&#125;。&apos;.format(math.pi))</span><br><span class=\"line\">常量 PI 的值近似为： 3.141592653589793。</span><br></pre></td></tr></table></figure></p>\n<p>可选项 <code>:</code> 和格式标识符可以跟着字段名。这就允许对值进行更好的格式化。<br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  将 Pi 保留小数点后三位</span><br><span class=\"line\">&gt;&gt;&gt; import math</span><br><span class=\"line\">&gt;&gt;&gt; print(&apos;常量 PI 的值近似为 &#123;0:.3f&#125;。&apos;.format(math.pi))</span><br><span class=\"line\">常量 PI 的值近似为 3.142。</span><br></pre></td></tr></table></figure></p>\n<p>在 <code>:</code> 后传入一个整数，可以保证该域至少有这么多的宽度。用于美化表格时很有用。<br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; table = &#123;&apos;Google&apos;: 1, &apos;Runoob&apos;: 2, &apos;Taobao&apos;: 3&#125;</span><br><span class=\"line\">&gt;&gt;&gt; for name, number in table.items():</span><br><span class=\"line\">...     print(&apos;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&apos;.format(name, number))</span><br><span class=\"line\">...</span><br><span class=\"line\">Runoob     ==&gt;          2</span><br><span class=\"line\">Taobao     ==&gt;          3</span><br><span class=\"line\">Google     ==&gt;          1</span><br></pre></td></tr></table></figure></p>\n<p>如果有一个很长的格式化字符串，而不想将它们分开，那么在格式化时通过变量名而非位置会是很好的事情。<br>最简单的就是传入一个字典，然后使用 <code>[]</code> 来访问键值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; table = &#123;&apos;Google&apos;: 1, &apos;Runoob&apos;: 2, &apos;Taobao&apos;: 3&#125;</span><br><span class=\"line\">&gt;&gt;&gt; print(&apos;Runoob: &#123;0[Runoob]:d&#125;; Google: &#123;0[Google]:d&#125;; Taobao: &#123;0[Taobao]:d&#125;&apos;.format(table))</span><br><span class=\"line\">Runoob: 2; Google: 1; Taobao: 3</span><br></pre></td></tr></table></figure></p>\n<p>也可以通过在 table 变量前使用 <code>**</code> 来实现相同的功能。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; table = &#123;&apos;Google&apos;: 1, &apos;Runoob&apos;: 2, &apos;Taobao&apos;: 3&#125;</span><br><span class=\"line\">&gt;&gt;&gt; print(&apos;Runoob: &#123;Runoob:d&#125;; Google: &#123;Google:d&#125;; Taobao: &#123;Taobao:d&#125;&apos;.format(**table))</span><br><span class=\"line\">Runoob: 2; Google: 1; Taobao: 3</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"15-4-旧式字符串格式化\"><a href=\"#15-4-旧式字符串格式化\" class=\"headerlink\" title=\"15.4 旧式字符串格式化\"></a>15.4 旧式字符串格式化</h3><p><code>%</code> 操作符也可以实现字符串格式化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; import math</span><br><span class=\"line\">&gt;&gt;&gt; print(&apos;常量 PI 的值近似为：%5.3f。&apos; % math.pi)</span><br><span class=\"line\">常量 PI 的值近似为：3.142。</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注：因为 <code>str.format()</code> 是比较新的函数，大多数的 Python 代码仍然使用 <code>%</code> 操作符。但是因为这种旧式&gt; 的格式化最终会从该语言中移除，应该更多的使用 <code>str.format()</code>。</p>\n</blockquote>\n<h3 id=\"15-5-读取键盘输入\"><a href=\"#15-5-读取键盘输入\" class=\"headerlink\" title=\"15.5 读取键盘输入\"></a>15.5 读取键盘输入</h3><p><code>input()</code> 内置函数从标准输入读入一行文本，默认的标准输入是键盘。<br><code>input()</code> 可以接收一个 Python 表达式作为输入，通过 <code>eval()</code> 函数转化并将运算结果返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = input(&quot;请输入：&quot;)</span><br><span class=\"line\">print(eval(result))</span><br><span class=\"line\"></span><br><span class=\"line\">请输入：3+3</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"15-6-读和写文件\"><a href=\"#15-6-读和写文件\" class=\"headerlink\" title=\"15.6 读和写文件\"></a>15.6 读和写文件</h3><p><code>open()</code> 将会返回一个 file 对象。<br>常用语法格式：<code>open(filename, mode)</code><br>完整语法格式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(file, mode=&apos;r&apos;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>filename：必需，文件路径（相对或绝对路径）。</li>\n<li>mode：可选，打开文件的模式。默认文件访问模式为只读（r）。默认为文本模式，如果要以二进制模式打开，加上 b。</li>\n<li>buffering：设置缓冲。</li>\n<li>encoding：一般使用 utf-8</li>\n<li>errors：报错级别</li>\n<li>newline：区分换行符</li>\n<li>closefd：传入的 file 参数类型</li>\n<li>opener：</li>\n</ul>\n<blockquote>\n<p>注意：使用 <code>open()</code> 方法一定要保证关闭文件对象，即调用 <code>close()</code> 方法。</p>\n</blockquote>\n<p>不同模式打开文件的完全列表：<br><img src=\"/2019/01/19/Python3-Basic/OpenFileMode.JPG\" alt=\"OpenFileMode\"><br>逻辑总结：<br><img src=\"/2019/01/19/Python3-Basic/ModeSummary.JPG\" alt=\"ModeSummary\"></p>\n<h4 id=\"15-6-1-f-read-读取一个文件的内容\"><a href=\"#15-6-1-f-read-读取一个文件的内容\" class=\"headerlink\" title=\"15.6.1 f.read() - 读取一个文件的内容\"></a>15.6.1 f.read() - 读取一个文件的内容</h4><p><code>f.read(size)</code>, 这将读取一定数目的数据，然后作为字符串或字节对象返回。<br><code>size</code> 是可选的数字类型参数。当 <code>size</code> 被忽略或者为负，那么该文件的所有内容都将被读取并且返回。</p>\n<h4 id=\"15-6-2-f-readline-从文件中读取单独的一行\"><a href=\"#15-6-2-f-readline-从文件中读取单独的一行\" class=\"headerlink\" title=\"15.6.2 f.readline() - 从文件中读取单独的一行\"></a>15.6.2 f.readline() - 从文件中读取单独的一行</h4><p>换行符为 <code>\\n</code> 。如果返回一个空字符串，说明已经读取到最后一行。</p>\n<h4 id=\"15-6-3-f-readlines-读取该文件中包含的所有行并返回列表\"><a href=\"#15-6-3-f-readlines-读取该文件中包含的所有行并返回列表\" class=\"headerlink\" title=\"15.6.3 f.readlines() - 读取该文件中包含的所有行并返回列表\"></a>15.6.3 f.readlines() - 读取该文件中包含的所有行并返回列表</h4><p>如果设置可选参数 <code>sizehint</code>, 则读取指定长度的子节，并将这些子节按行分割。</p>\n<h4 id=\"15-6-4-迭代文件对象读取\"><a href=\"#15-6-4-迭代文件对象读取\" class=\"headerlink\" title=\"15.6.4 迭代文件对象读取\"></a>15.6.4 迭代文件对象读取</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fRead = open(&apos;F:/Python project/Demo/Demo.txt&apos;)</span><br><span class=\"line\">for line in fRead:</span><br><span class=\"line\">    print(line,end=&apos;&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">fRead.close()</span><br></pre></td></tr></table></figure>\n<h4 id=\"15-6-5-f-write-string-将字符串写入到文件中，返回写入的字符数\"><a href=\"#15-6-5-f-write-string-将字符串写入到文件中，返回写入的字符数\" class=\"headerlink\" title=\"15.6.5 f.write(string) - 将字符串写入到文件中，返回写入的字符数\"></a>15.6.5 f.write(string) - 将字符串写入到文件中，返回写入的字符数</h4><p>如果要写入一些不是字符串的内容，需要先将此内容转换为字符串形式。  </p>\n<h4 id=\"15-6-7-f-tell-返回文件对象当前所处的位置，它是从文件开头开始算起的字节数\"><a href=\"#15-6-7-f-tell-返回文件对象当前所处的位置，它是从文件开头开始算起的字节数\" class=\"headerlink\" title=\"15.6.7 f.tell() - 返回文件对象当前所处的位置，它是从文件开头开始算起的字节数\"></a>15.6.7 f.tell() - 返回文件对象当前所处的位置，它是从文件开头开始算起的字节数</h4><h4 id=\"15-6-8-f-seek-改变文件当前的位置\"><a href=\"#15-6-8-f-seek-改变文件当前的位置\" class=\"headerlink\" title=\"15.6.8 f.seek() - 改变文件当前的位置\"></a>15.6.8 f.seek() - 改变文件当前的位置</h4><p>语法：<code>f.seek(offset, from_what)</code>。<br><code>offset</code>：移动的字符个数。<br><code>from_what</code>：0 - 开头，1 - 当前位置，2 - 文件的结尾。默认值为 0。</p>\n<h4 id=\"15-6-9-f-close-关闭文件并释放系统的资源\"><a href=\"#15-6-9-f-close-关闭文件并释放系统的资源\" class=\"headerlink\" title=\"15.6.9 f.close() - 关闭文件并释放系统的资源\"></a>15.6.9 f.close() - 关闭文件并释放系统的资源</h4><p>写入数据后，切记要调用 <code>f.close()</code>，不然数据流可能未完全写入文件中。<br>使用 <code>with</code> 关键字是非常好的方式。在结束后，它会自动正确的关闭文件，而且写起来也比 <code>try - finally</code> 语句块要简短。  </p>\n<blockquote>\n<p>注：with…as… 含义：<br><code>with</code> 所求值的对象必须有一个 <code>__enter__()</code> 方法和一个 <code>__exit__()</code> 方法。<br>紧跟 <code>with</code> 后面的语句被求值后，返回对象的 <code>__enter__()</code> 方法被调用，这个方法的返回值将被赋值给 &gt; <code>as</code> 后面的变量。当 <code>with</code> 后面的代码块被全部执行完之后，将调用前面返回对象的 <code>__exit()__</code> 方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; with open(&apos;/tmp/foo.txt&apos;, &apos;r&apos;) as f:</span><br><span class=\"line\">             read_data = f.read()</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"15-6-10-f-flush-刷新文件内部缓冲\"><a href=\"#15-6-10-f-flush-刷新文件内部缓冲\" class=\"headerlink\" title=\"15.6.10 f.flush() - 刷新文件内部缓冲\"></a>15.6.10 f.flush() - 刷新文件内部缓冲</h4><p>直接把内部缓冲区的数据立刻写入文件，而不是被动等待输出缓冲区写入。</p>\n<h4 id=\"15-6-11-f-fileno-返回一个整型的文件描述符（file-descriptor-FD-整型）\"><a href=\"#15-6-11-f-fileno-返回一个整型的文件描述符（file-descriptor-FD-整型）\" class=\"headerlink\" title=\"15.6.11 f.fileno() - 返回一个整型的文件描述符（file descriptor FD 整型）\"></a>15.6.11 f.fileno() - 返回一个整型的文件描述符（file descriptor FD 整型）</h4><p>可以用在如 os 模块的 <code>read</code> 方法等一些底层操作上。</p>\n<h4 id=\"15-6-12-f-isatty-如果文件连接到一个终端设备返回-True，否则返回-False。\"><a href=\"#15-6-12-f-isatty-如果文件连接到一个终端设备返回-True，否则返回-False。\" class=\"headerlink\" title=\"15.6.12 f.isatty() - 如果文件连接到一个终端设备返回 True，否则返回 False。\"></a>15.6.12 f.isatty() - 如果文件连接到一个终端设备返回 True，否则返回 False。</h4><h4 id=\"15-6-13-f-next-返回文件下一行\"><a href=\"#15-6-13-f-next-返回文件下一行\" class=\"headerlink\" title=\"15.6.13 f.next() - 返回文件下一行\"></a>15.6.13 f.next() - 返回文件下一行</h4><h4 id=\"15-6-14-f-truncate-size-字符截断\"><a href=\"#15-6-14-f-truncate-size-字符截断\" class=\"headerlink\" title=\"15.6.14 f.truncate([size]) - 字符截断\"></a>15.6.14 f.truncate([size]) - 字符截断</h4><p>从文件的首行首字符开始截断，截断的文件为 <code>size</code> 个字符，无 <code>size</code> 表示从当前位置截断；截断之后后面的所有字符被删除，其中 Windows 系统下的换行代表 2 个字符大小。</p>\n<h4 id=\"15-6-15-f-writelines-sepuence-向文件写入一个序列字符串列表\"><a href=\"#15-6-15-f-writelines-sepuence-向文件写入一个序列字符串列表\" class=\"headerlink\" title=\"15.6.15 f.writelines(sepuence) - 向文件写入一个序列字符串列表\"></a>15.6.15 f.writelines(sepuence) - 向文件写入一个序列字符串列表</h4><p>如果需要换行则要自己加入每行的换行符。</p>\n<h3 id=\"15-7-pickle-模块\"><a href=\"#15-7-pickle-模块\" class=\"headerlink\" title=\"15.7 pickle 模块\"></a>15.7 pickle 模块</h3><p>Python 的 pickle 模块实现了基本的数据序列化和反序列化。<br>通过 pickle 模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。<br>通过 pickle 模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。<br>基本接口：<code>pickle.dump(obj, file[, protocol])</code><br>有了 pickle 这个对象就能对 file 以读取形式打开：<code>x = pickle.load(file)</code> </p>\n<blockquote>\n<p>注：从 file 中读取一个字符串，并将它重构为原来的 Python 对象。<br>file - 类文件对象。</p>\n</blockquote>\n<h3 id=\"15-8-OS-文件-目录方法\"><a href=\"#15-8-OS-文件-目录方法\" class=\"headerlink\" title=\"15.8 OS 文件/目录方法\"></a>15.8 OS 文件/目录方法</h3><p>os 模块提供了非常丰富的方法用来处理文件和目录。</p>\n<hr>\n<h2 id=\"16-错误和异常\"><a href=\"#16-错误和异常\" class=\"headerlink\" title=\"16. 错误和异常\"></a>16. 错误和异常</h2><p>两种错误：语法错误和异常。</p>\n<h3 id=\"16-1-语法错误或者称之为解析错（SyntaxError）\"><a href=\"#16-1-语法错误或者称之为解析错（SyntaxError）\" class=\"headerlink\" title=\"16.1 语法错误或者称之为解析错（SyntaxError）\"></a>16.1 语法错误或者称之为解析错（SyntaxError）</h3><p>语法分析器找出出错行，并在错误位置标记一个小小的箭头。</p>\n<h3 id=\"16-2-异常\"><a href=\"#16-2-异常\" class=\"headerlink\" title=\"16.2 异常\"></a>16.2 异常</h3><p>运行期间检测到的错误称为异常。<br>大多数异常都不会被程序处理，都以错误的形式展现出来。<br>异常以不同的类型出现，这些类型都作为信息的一部分打印出来，例如（NameError、Type Error等）。<br>错误信息的前面部分显示了异常发生的上下文，并以调用栈的形式显示具体信息。</p>\n<h3 id=\"16-3-异常处理（try…except…）\"><a href=\"#16-3-异常处理（try…except…）\" class=\"headerlink\" title=\"16.3 异常处理（try…except…）\"></a>16.3 异常处理（try…except…）</h3><p>首先执行 <code>try</code> 子句，如果没有异常发生，忽略 <code>except</code> 子句，<code>try</code> 子句执行后结束。<br>如果在执行 <code>try</code> 子句的过程中发生了异常，那么<strong> try 子句余下的部分将被忽略</strong>。若异常类型与 <code>except</code> 之后的名称相符，那么对应的 <code>except</code> 子句将被执行，若有异常没有与任何的 <code>except</code> 匹配，那么这个异常将被传递给上层的 <code>try</code> 中。<br>一个 <code>try</code> 语句可能包含多个 <code>except</code> 子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。<br>一个 <code>except</code> 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">except (RuntimeError, TypeError, NameError):</span><br><span class=\"line\">        pass</span><br></pre></td></tr></table></figure></p>\n<p>处理程序将只针对对应的 <code>try</code> 子句中的异常进行处理，而不是其他的 <code>try</code> 的处理程序中的异常。<br><code>try except</code> 语句还有一个可选的 <code>else</code> 子句，此子句必须放在所有的 <code>except</code> 子句之后。这个子句将在 <code>try</code> 子句没有发生任何异常的时候执行。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try:</span><br><span class=\"line\">        f = open(arg, &apos;r&apos;)</span><br><span class=\"line\">    except IOError:</span><br><span class=\"line\">        print(&apos;cannot open&apos;, arg)</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(arg, &apos;has&apos;, len(f.readlines()), &apos;lines&apos;)</span><br><span class=\"line\">        f.close()</span><br></pre></td></tr></table></figure></p>\n<p>异常处理并不仅仅处理那些直接发生在 <code>try</code> 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。</p>\n<h3 id=\"16-4-抛出异常\"><a href=\"#16-4-抛出异常\" class=\"headerlink\" title=\"16.4 抛出异常\"></a>16.4 抛出异常</h3><p>使用 <code>raise</code> 语句抛出一个指定的异常。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;raise NameError(&apos;HiThere&apos;)</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class=\"line\">NameError: HiThere</span><br></pre></td></tr></table></figure></p>\n<p><code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。<br>如果只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 <code>raise</code> 语句就可以再次把它抛出。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;try:</span><br><span class=\"line\">        raise NameError(&apos;HiThere&apos;)</span><br><span class=\"line\">    except NameError:</span><br><span class=\"line\">        print(&apos;An exception flew by!&apos;)</span><br><span class=\"line\">        raise</span><br><span class=\"line\">   </span><br><span class=\"line\">An exception flew by!</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 2, in ?</span><br><span class=\"line\">NameError: HiThere</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"16-5-用户自定义异常\"><a href=\"#16-5-用户自定义异常\" class=\"headerlink\" title=\"16.5 用户自定义异常\"></a>16.5 用户自定义异常</h3><p>可通过创建一个新的异常类来拥有自己的异常。异常类继承自 <code>Exception</code> 类，可以直接继承或者间接继承。<br>大多数异常的名字都以 <code>Error</code> 结尾，就跟标准的异常命名一样。<br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt;class MyError(Exception):</span><br><span class=\"line\">        def __init__(self, value):</span><br><span class=\"line\">            self.value = value</span><br><span class=\"line\">        def __str__(self):</span><br><span class=\"line\">            return repr(self.value)</span><br><span class=\"line\">   </span><br><span class=\"line\">&gt;&gt;&gt; try:</span><br><span class=\"line\">        raise MyError(2*2)</span><br><span class=\"line\">    except MyError as e:</span><br><span class=\"line\">        print(&apos;My exception occurred, value:&apos;, e.value)</span><br><span class=\"line\">   </span><br><span class=\"line\">My exception occurred, value: 4</span><br><span class=\"line\">&gt;&gt;&gt; raise MyError(&apos;oops!&apos;)</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span><br><span class=\"line\">__main__.MyError: &apos;oops!&apos;</span><br></pre></td></tr></table></figure></p>\n<p>上例中，类 <code>Exception</code> 默认的 <code>__init__()</code> 被覆盖。<br>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类。</p>\n<h3 id=\"16-6-定义清理行为\"><a href=\"#16-6-定义清理行为\" class=\"headerlink\" title=\"16.6 定义清理行为\"></a>16.6 定义清理行为</h3><p><code>try</code> 语句还有另外一个可选的子句 - <code>finally</code>，它定义了无论在任何情况下都会执行的清理行为：<br>不管 <code>try</code> 子句里有没有发生异常，<code>finally</code> 子句都会执行。<br>如果一个异常在 <code>try</code> 子句里（或者在 <code>except</code> 和 <code>else</code> 子句里）被抛出，而又没有任何的 <code>except</code> 把它截住，那么这个异常会在 <code>finally</code> 子句执行后再次被抛出（异常只显示一次）。</p>\n<h3 id=\"16-7-预定义的清理行为\"><a href=\"#16-7-预定义的清理行为\" class=\"headerlink\" title=\"16.7 预定义的清理行为\"></a>16.7 预定义的清理行为</h3><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。<br><code>with</code> 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法。</p>\n<hr>\n<h2 id=\"17-Python3-面向对象\"><a href=\"#17-Python3-面向对象\" class=\"headerlink\" title=\"17. Python3 面向对象\"></a>17. Python3 面向对象</h2><p>Python 中的类提供了面向对象编程的所有基本功能。<br><strong>另外：类的继承机制允许多个基类。</strong></p>\n<h3 id=\"17-1-类定义\"><a href=\"#17-1-类定义\" class=\"headerlink\" title=\"17.1 类定义\"></a>17.1 类定义</h3><p>语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ClassName:</span><br><span class=\"line\">    &lt;statement-1&gt;</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure></p>\n<p>创建一个类之后，可以通过类名访问其属性。<br><strong>属性或方法名前加双下划线的为私有属性，外部不可直接访问。</strong><br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class People:</span><br><span class=\"line\">    name = &apos;&apos;</span><br><span class=\"line\">    age = 0</span><br><span class=\"line\">    __weight = 0</span><br><span class=\"line\">    def __init__(self, name, age, weight):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\">        self.__weight = weight</span><br><span class=\"line\">    def __show(self):</span><br><span class=\"line\">        print(&quot;%s - %d&quot; %(self.name, self.age))</span><br><span class=\"line\">    def test(xxx):</span><br><span class=\"line\">        xxx.__show()</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">ywang - 22</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;F:\\Python project\\Demo\\Demo.py&quot;, line 16, in &lt;module&gt;</span><br><span class=\"line\">    oP.__show()</span><br><span class=\"line\">AttributeError: &apos;People&apos; object has no attribute &apos;__show&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">#  属性 __weight 与 方法 __show() 为私有方法，外部不可访问，通过 test() 桥接后可访问。</span><br><span class=\"line\">#  类内部访问私有属性及调用方法时通过 self.__private_attrs, self.__private_methods</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"17-2-类对象\"><a href=\"#17-2-类对象\" class=\"headerlink\" title=\"17.2 类对象\"></a>17.2 类对象</h3><p>类对象支持两种操作：属性引用和实例化。<br>属性引用语法：<code>obj.name</code>。</p>\n<h4 id=\"17-2-1-构造方法-init\"><a href=\"#17-2-1-构造方法-init\" class=\"headerlink\" title=\"17.2.1 构造方法 - init()\"></a>17.2.1 构造方法 - <strong>init</strong>()</h4><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>，按照惯例它的名称是 <code>self</code>，代表当前对象地址。<br><strong><code>self</code> 不是 Python 关键字，换成其他名称也可以。</strong></p>\n<h3 id=\"17-3-类的方法\"><a href=\"#17-3-类的方法\" class=\"headerlink\" title=\"17.3 类的方法\"></a>17.3 类的方法</h3><p>在类的内部，使用 <code>def</code> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <code>self</code>，且为第一个参数，<code>self</code> 代表的是类的实例。<br>调用方法传参时忽略第一个参数 <code>self</code>，此参数不需要传，传递的参数从第二个开始。</p>\n<h3 id=\"17-4-继承\"><a href=\"#17-4-继承\" class=\"headerlink\" title=\"17.4 继承\"></a>17.4 继承</h3><p><strong>支持多继承。</strong><br>语法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class DerivedClassName(BaseClassName1[, BaseClassName2, BaseClassName3, ...]):</span><br><span class=\"line\">    &lt;statement-1&gt;</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure></p>\n<p>需注意圆括号中基类的顺序，若基类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索。<br>基类必须与派生类定义在一个作用域内。（比如继承未导入模块中的类）<br>除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用。例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class DerivedClassName(modname.BaseClassName):</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"17-5-方法重写\"><a href=\"#17-5-方法重写\" class=\"headerlink\" title=\"17.5 方法重写\"></a>17.5 方法重写</h3><p>在基类中定义与父类方法同名方法即可重写父类中方法。</p>\n<h3 id=\"17-6-类的专有方法\"><a href=\"#17-6-类的专有方法\" class=\"headerlink\" title=\"17.6 类的专有方法\"></a>17.6 类的专有方法</h3><ul>\n<li><strong>init</strong> : 构造函数</li>\n<li><strong>del</strong> : 析构函数</li>\n<li><strong>repr</strong> : 打印，转换</li>\n<li><strong>setitem</strong> : 按照索引赋值</li>\n<li><strong>getitem</strong> : 按照索引获取值</li>\n<li><strong>len</strong> : 获得长度</li>\n<li><strong>cmp</strong> : 比较运算</li>\n<li><strong>call</strong> : 函数调用</li>\n<li><strong>add</strong> : 加运算</li>\n<li><strong>sub</strong> : 减运算</li>\n<li><strong>mul</strong> : 乘运算</li>\n<li><strong>truediv</strong> : 除运算</li>\n<li><strong>mod</strong> : 求余运算</li>\n<li><strong>pow</strong> : 乘方</li>\n</ul>\n<h3 id=\"17-7-运算符重载\"><a href=\"#17-7-运算符重载\" class=\"headerlink\" title=\"17.7 运算符重载\"></a>17.7 运算符重载</h3><p>Python 支持运算符重载，可以对类的专有方法重载。</p>\n<hr>\n<h2 id=\"18-标准库概览\"><a href=\"#18-标准库概览\" class=\"headerlink\" title=\"18. 标准库概览\"></a>18. 标准库概览</h2><h3 id=\"18-1-操作系统接口\"><a href=\"#18-1-操作系统接口\" class=\"headerlink\" title=\"18.1 操作系统接口\"></a>18.1 操作系统接口</h3><p>os 模块提供了不少与操作系统相关联的函数。<br>建议使用 <code>import os</code> 风格而非 <code>from os import *</code>。这样可以保证随操作系统不同而有所变化的 <code>os.open()</code> 不会覆盖内置函数 <code>open()</code>。<br>在使用 os 这样的大型模块时内置的 <code>dir()</code> 和 <code>help()</code> 函数非常有用。<br>针对日常的文件和目录管理任务，:mod:shutil 模块提供了一个易于使用的高级接口。</p>\n<h3 id=\"18-2-文件通配符\"><a href=\"#18-2-文件通配符\" class=\"headerlink\" title=\"18.2 文件通配符\"></a>18.2 文件通配符</h3><p><code>glob</code> 模块提供了一个函数用于从目录通配符搜索中生成文件列表：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; import glob</span><br><span class=\"line\">&gt;&gt;&gt; glob.glob(&apos;*.py&apos;)</span><br><span class=\"line\">[&apos;primes.py&apos;, &apos;random.py&apos;, &apos;quote.py&apos;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"18-3-命令行参数\"><a href=\"#18-3-命令行参数\" class=\"headerlink\" title=\"18.3 命令行参数\"></a>18.3 命令行参数</h3><p>通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 <code>sys</code> 模块的 <code>argv</code> 变量。<br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  在命令行中执行 &quot;python demo.py one two three&quot; </span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; import sys</span><br><span class=\"line\">&gt;&gt;&gt; print(sys.argv)</span><br><span class=\"line\">[&apos;demo.py&apos;, &apos;one&apos;, &apos;two&apos;, &apos;three&apos;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"18-4-错误输出重定向和程序终止\"><a href=\"#18-4-错误输出重定向和程序终止\" class=\"headerlink\" title=\"18.4 错误输出重定向和程序终止\"></a>18.4 错误输出重定向和程序终止</h3><p><code>sys</code> 还有 <code>stdin，stdout 和 stderr</code> 属性，即使在 <code>stdout</code> 被重定向时，后者也可以用于显示警告和错误信息。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; sys.stderr.write(&apos;Warning, log file not found starting a new one\\n&apos;)</span><br><span class=\"line\">Warning, log file not found starting a new one</span><br></pre></td></tr></table></figure></p>\n<p>大多数脚本的定向终止都使用 <code>sys.exit()</code>。</p>\n<h3 id=\"18-5-字符串正则匹配\"><a href=\"#18-5-字符串正则匹配\" class=\"headerlink\" title=\"18.5 字符串正则匹配\"></a>18.5 字符串正则匹配</h3><p>re 模块为高级字符串处理提供了正则表达式。对于复杂的匹配和处理，正则表达式提供了简介、优化的解决方案。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; import re</span><br><span class=\"line\">&gt;&gt;&gt; re.findall(r&apos;\\bf[a-z]*&apos;, &apos;which foot or hand fell fastest&apos;)</span><br><span class=\"line\">[&apos;foot&apos;, &apos;fell&apos;, &apos;fastest&apos;]</span><br><span class=\"line\">&gt;&gt;&gt; re.sub(r&apos;(\\b[a-z]+) \\1&apos;, r&apos;\\1&apos;, &apos;cat in the the hat&apos;)</span><br><span class=\"line\">&apos;cat in the hat&apos;</span><br></pre></td></tr></table></figure></p>\n<p>如果只需要简单的功能，应该首先考虑字符串的方法，因为它们非常简单，易于阅读和调试。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; &apos;tea for too&apos;.replace(&apos;too&apos;, &apos;two&apos;)</span><br><span class=\"line\">&apos;tea for two&apos;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"18-6-数学\"><a href=\"#18-6-数学\" class=\"headerlink\" title=\"18.6 数学\"></a>18.6 数学</h3><p>math 模块为浮点运算提供了对底层 C 函数库的访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; import math</span><br><span class=\"line\">&gt;&gt;&gt; math.cos(math.pi / 4)</span><br><span class=\"line\">0.70710678118654757</span><br><span class=\"line\">&gt;&gt;&gt; math.log(1024, 2)</span><br><span class=\"line\">10.0</span><br></pre></td></tr></table></figure></p>\n<p>random 提供了生成随机数的工具<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; import random</span><br><span class=\"line\">&gt;&gt;&gt; random.choice([&apos;apple&apos;, &apos;pear&apos;, &apos;banana&apos;])</span><br><span class=\"line\">&apos;apple&apos;</span><br><span class=\"line\">&gt;&gt;&gt; random.sample(range(100), 10)   # sampling without replacement</span><br><span class=\"line\">[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]</span><br><span class=\"line\">&gt;&gt;&gt; random.random()    # random float</span><br><span class=\"line\">0.17970987693706186</span><br><span class=\"line\">&gt;&gt;&gt; random.randrange(6)    # random integer chosen from range(6)</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"18-7-访问互联网\"><a href=\"#18-7-访问互联网\" class=\"headerlink\" title=\"18.7 访问互联网\"></a>18.7 访问互联网</h3><p>有几个模块用于访问互联网以及处理网络通信协议。<br>其中最简单的两个是用于处理从 <code>urls</code> 接收的数据的 <code>urllib.request</code> 以及用于发送电子邮件的  <code>smtplib</code>。</p>\n<h3 id=\"18-8-日期和时间\"><a href=\"#18-8-日期和时间\" class=\"headerlink\" title=\"18.8 日期和时间\"></a>18.8 日期和时间</h3><p><code>datetime</code> 模块为日期和时间处理同时提供了简单和复杂的方法。<br>支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。<br>该模块还支持时区处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; # dates are easily constructed and formatted</span><br><span class=\"line\">&gt;&gt;&gt; from datetime import date</span><br><span class=\"line\">&gt;&gt;&gt; now = date.today()</span><br><span class=\"line\">&gt;&gt;&gt; now</span><br><span class=\"line\">datetime.date(2003, 12, 2)</span><br><span class=\"line\">&gt;&gt;&gt; now.strftime(&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;)</span><br><span class=\"line\">&apos;12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; # dates support calendar arithmetic</span><br><span class=\"line\">&gt;&gt;&gt; birthday = date(1964, 7, 31)</span><br><span class=\"line\">&gt;&gt;&gt; age = now - birthday</span><br><span class=\"line\">&gt;&gt;&gt; age.days</span><br><span class=\"line\">14368</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"18-9-数据压缩\"><a href=\"#18-9-数据压缩\" class=\"headerlink\" title=\"18.9 数据压缩\"></a>18.9 数据压缩</h3><p>以下模块直接支持通用的数据打包和压缩格式：<code>zlib, gzip, bz2, zipfile 以及 tarfile</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; import zlib</span><br><span class=\"line\">&gt;&gt;&gt; s = b&apos;witch which has which witches wrist watch&apos;</span><br><span class=\"line\">&gt;&gt;&gt; len(s)</span><br><span class=\"line\">41</span><br><span class=\"line\">&gt;&gt;&gt; t = zlib.compress(s)</span><br><span class=\"line\">&gt;&gt;&gt; len(t)</span><br><span class=\"line\">37</span><br><span class=\"line\">&gt;&gt;&gt; zlib.decompress(t)</span><br><span class=\"line\">b&apos;witch which has which witches wrist watch&apos;</span><br><span class=\"line\">&gt;&gt;&gt; zlib.crc32(s)</span><br><span class=\"line\">226805979</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"18-10-性能度量\"><a href=\"#18-10-性能度量\" class=\"headerlink\" title=\"18.10 性能度量\"></a>18.10 性能度量</h3><p>有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。<br>例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#  使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多</span><br><span class=\"line\">#  timeit 证明现代的方法更快一些</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; from timeit import Timer</span><br><span class=\"line\">&gt;&gt;&gt; Timer(&apos;t=a; a=b; b=t&apos;, &apos;a=1; b=2&apos;).timeit()</span><br><span class=\"line\">0.57535828626024577</span><br><span class=\"line\">&gt;&gt;&gt; Timer(&apos;a,b = b,a&apos;, &apos;a=1; b=2&apos;).timeit()</span><br><span class=\"line\">0.54962537085770791</span><br></pre></td></tr></table></figure></p>\n<p>相对于 <code>timeit</code> 的细粒度，:mod:profile 和 pstats 模块提供了针对更大代码块的时间度量工具。</p>\n<h3 id=\"18-11-测试模块\"><a href=\"#18-11-测试模块\" class=\"headerlink\" title=\"18.11 测试模块\"></a>18.11 测试模块</h3><p>开发高质量软件的方法之一是为每一个函数开发测试代码，并且在开发过程中经常进行测试。<br><code>doctest</code> 模块提供了一个工具，扫描模块并根据程序中内嵌的文档字符串执行测试。<br>测试构造如同简单的将它的输出结果剪切并粘贴到文档字符串中。<br>通过用户提供的例子，它强化了文档，允许 <code>doctest</code> 模块确认代码的结果是否与文档一致:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def average(values):</span><br><span class=\"line\">    &quot;&quot;&quot;Computes the arithmetic mean of a list of numbers.</span><br><span class=\"line\"></span><br><span class=\"line\">    &gt;&gt;&gt; print(average([20, 30, 70]))</span><br><span class=\"line\">    40.0</span><br><span class=\"line\">    &quot;&quot;&quot;</span><br><span class=\"line\">    return sum(values) / len(values)</span><br><span class=\"line\"></span><br><span class=\"line\">import doctest</span><br><span class=\"line\">doctest.testmod()   # 自动验证嵌入测试</span><br><span class=\"line\"></span><br><span class=\"line\">unittest 模块不像 doctest 模块那么容易使用，不过它可以在一个独立的文件里提供一个更全面的测试集:</span><br><span class=\"line\"></span><br><span class=\"line\">import unittest</span><br><span class=\"line\"></span><br><span class=\"line\">class TestStatisticalFunctions(unittest.TestCase):</span><br><span class=\"line\"></span><br><span class=\"line\">    def test_average(self):</span><br><span class=\"line\">        self.assertEqual(average([20, 30, 70]), 40.0)</span><br><span class=\"line\">        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)</span><br><span class=\"line\">        self.assertRaises(ZeroDivisionError, average, [])</span><br><span class=\"line\">        self.assertRaises(TypeError, average, 20, 30, 70)</span><br><span class=\"line\"></span><br><span class=\"line\">unittest.main() # Calling from the command line invokes all tests</span><br></pre></td></tr></table></figure></p>\n","categories":[],"tags":[{"name":"Python","slug":"Python","count":1,"path":"api/tags/Python.json"}]}